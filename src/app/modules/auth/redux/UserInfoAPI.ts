//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IAddressClient {
    getProvincesAll(): Promise<Province[]>;
    getProvinces(id: number | undefined): Promise<Province>;
    getDistrictByProvinceId(provinceId: number | undefined): Promise<District[]>;
    getDistrict(id: number | undefined): Promise<District>;
    getWardAll(): Promise<Ward[]>;
    getWardByDistrictId(id: number | undefined): Promise<Ward[]>;
    getWard(id: number | undefined): Promise<Ward>;
}

export class AddressClient implements IAddressClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getProvincesAll(  cancelToken?: CancelToken | undefined): Promise<Province[]> {
        let url_ = this.baseUrl + "/api/Address/GetProvinces";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProvincesAll(_response);
        });
    }

    protected processGetProvincesAll(response: AxiosResponse): Promise<Province[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Province.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Province[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Province[]>(null as any);
    }

    getProvinces(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<Province> {
        let url_ = this.baseUrl + "/api/Address/GetProvincesById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProvinces(_response);
        });
    }

    protected processGetProvinces(response: AxiosResponse): Promise<Province> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Province.fromJS(resultData200);
            return Promise.resolve<Province>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Province>(null as any);
    }

    getDistrictByProvinceId(provinceId: number | undefined , cancelToken?: CancelToken | undefined): Promise<District[]> {
        let url_ = this.baseUrl + "/api/Address/GetDistrictByProvinceId?";
        if (provinceId === null)
            throw new Error("The parameter 'provinceId' cannot be null.");
        else if (provinceId !== undefined)
            url_ += "provinceId=" + encodeURIComponent("" + provinceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDistrictByProvinceId(_response);
        });
    }

    protected processGetDistrictByProvinceId(response: AxiosResponse): Promise<District[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(District.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<District[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<District[]>(null as any);
    }

    getDistrict(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<District> {
        let url_ = this.baseUrl + "/api/Address/GetDistrictById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDistrict(_response);
        });
    }

    protected processGetDistrict(response: AxiosResponse): Promise<District> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = District.fromJS(resultData200);
            return Promise.resolve<District>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<District>(null as any);
    }

    getWardAll(  cancelToken?: CancelToken | undefined): Promise<Ward[]> {
        let url_ = this.baseUrl + "/api/Address/GetAllWard";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetWardAll(_response);
        });
    }

    protected processGetWardAll(response: AxiosResponse): Promise<Ward[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Ward.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Ward[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Ward[]>(null as any);
    }

    getWardByDistrictId(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<Ward[]> {
        let url_ = this.baseUrl + "/api/Address/GetWardByDistrictId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetWardByDistrictId(_response);
        });
    }

    protected processGetWardByDistrictId(response: AxiosResponse): Promise<Ward[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Ward.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Ward[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Ward[]>(null as any);
    }

    getWard(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<Ward> {
        let url_ = this.baseUrl + "/api/Address/GetWardById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetWard(_response);
        });
    }

    protected processGetWard(response: AxiosResponse): Promise<Ward> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Ward.fromJS(resultData200);
            return Promise.resolve<Ward>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Ward>(null as any);
    }
}

export interface IAlbumClient {
    getAlbumAll(): Promise<Album[]>;
    postAlbum(album: Album): Promise<Album>;
    getAlbum(id: number): Promise<Album>;
    putAlbum(id: number, album: Album): Promise<Album>;
    deleteAlbum(id: number): Promise<Album>;
}

export class AlbumClient implements IAlbumClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getAlbumAll(  cancelToken?: CancelToken | undefined): Promise<Album[]> {
        let url_ = this.baseUrl + "/api/Album";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAlbumAll(_response);
        });
    }

    protected processGetAlbumAll(response: AxiosResponse): Promise<Album[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Album.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Album[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Album[]>(null as any);
    }

    postAlbum(album: Album , cancelToken?: CancelToken | undefined): Promise<Album> {
        let url_ = this.baseUrl + "/api/Album";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(album);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostAlbum(_response);
        });
    }

    protected processPostAlbum(response: AxiosResponse): Promise<Album> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Album.fromJS(resultData200);
            return Promise.resolve<Album>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Album>(null as any);
    }

    getAlbum(id: number , cancelToken?: CancelToken | undefined): Promise<Album> {
        let url_ = this.baseUrl + "/api/Album/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAlbum(_response);
        });
    }

    protected processGetAlbum(response: AxiosResponse): Promise<Album> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Album.fromJS(resultData200);
            return Promise.resolve<Album>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Album>(null as any);
    }

    putAlbum(id: number, album: Album , cancelToken?: CancelToken | undefined): Promise<Album> {
        let url_ = this.baseUrl + "/api/Album/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(album);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPutAlbum(_response);
        });
    }

    protected processPutAlbum(response: AxiosResponse): Promise<Album> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Album.fromJS(resultData200);
            return Promise.resolve<Album>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Album>(null as any);
    }

    deleteAlbum(id: number , cancelToken?: CancelToken | undefined): Promise<Album> {
        let url_ = this.baseUrl + "/api/Album/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAlbum(_response);
        });
    }

    protected processDeleteAlbum(response: AxiosResponse): Promise<Album> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Album.fromJS(resultData200);
            return Promise.resolve<Album>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Album>(null as any);
    }
}

export interface IAuthorizationClient {
    loginAdmin(login: LoginAdminRequest): Promise<LoginAdminResponse>;
    login(login: LoginRequest): Promise<UserResponse>;
    registerOrLoginFacebook(facebookuser: FacebookRequest): Promise<UserResponse>;
    registerOrLoginGoogle(googleuser: GoogleRequest): Promise<UserResponse>;
    registerOrLoginApple(appleuser: AppleLoginRequest): Promise<UserResponse>;
    registerPartner(input: RegisterPartner): Promise<RegisterPartner>;
}

export class AuthorizationClient implements IAuthorizationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    loginAdmin(login: LoginAdminRequest , cancelToken?: CancelToken | undefined): Promise<LoginAdminResponse> {
        let url_ = this.baseUrl + "/api/Authorization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLoginAdmin(_response);
        });
    }

    protected processLoginAdmin(response: AxiosResponse): Promise<LoginAdminResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LoginAdminResponse.fromJS(resultData200);
            return Promise.resolve<LoginAdminResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LoginAdminResponse>(null as any);
    }

    login(login: LoginRequest , cancelToken?: CancelToken | undefined): Promise<UserResponse> {
        let url_ = this.baseUrl + "/api/Authorization/LoginMobile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<UserResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserResponse.fromJS(resultData200);
            return Promise.resolve<UserResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserResponse>(null as any);
    }

    registerOrLoginFacebook(facebookuser: FacebookRequest , cancelToken?: CancelToken | undefined): Promise<UserResponse> {
        let url_ = this.baseUrl + "/api/Authorization/RegisterOrLoginFacebook";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(facebookuser);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegisterOrLoginFacebook(_response);
        });
    }

    protected processRegisterOrLoginFacebook(response: AxiosResponse): Promise<UserResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserResponse.fromJS(resultData200);
            return Promise.resolve<UserResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserResponse>(null as any);
    }

    registerOrLoginGoogle(googleuser: GoogleRequest , cancelToken?: CancelToken | undefined): Promise<UserResponse> {
        let url_ = this.baseUrl + "/api/Authorization/RegisterOrLoginGoogle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(googleuser);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegisterOrLoginGoogle(_response);
        });
    }

    protected processRegisterOrLoginGoogle(response: AxiosResponse): Promise<UserResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserResponse.fromJS(resultData200);
            return Promise.resolve<UserResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserResponse>(null as any);
    }

    registerOrLoginApple(appleuser: AppleLoginRequest , cancelToken?: CancelToken | undefined): Promise<UserResponse> {
        let url_ = this.baseUrl + "/api/Authorization/RegisterOrLoginApple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(appleuser);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegisterOrLoginApple(_response);
        });
    }

    protected processRegisterOrLoginApple(response: AxiosResponse): Promise<UserResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserResponse.fromJS(resultData200);
            return Promise.resolve<UserResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserResponse>(null as any);
    }

    registerPartner(input: RegisterPartner , cancelToken?: CancelToken | undefined): Promise<RegisterPartner> {
        let url_ = this.baseUrl + "/api/Authorization/RegisterPartner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegisterPartner(_response);
        });
    }

    protected processRegisterPartner(response: AxiosResponse): Promise<RegisterPartner> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RegisterPartner.fromJS(resultData200);
            return Promise.resolve<RegisterPartner>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RegisterPartner>(null as any);
    }
}

export interface IChatClient {
    getChatMessages(userId: number | undefined, chat: Chatcontact): Promise<Chatmessage[]>;
    getChatContacts(userId: number | undefined): Promise<Chatcontact[]>;
    getChatContactByUserId(user1: number | undefined, user2: number | undefined): Promise<Chatcontact>;
    sendChatMessage(message: Chatmessage): Promise<boolean>;
}

export class ChatClient implements IChatClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getChatMessages(userId: number | undefined, chat: Chatcontact , cancelToken?: CancelToken | undefined): Promise<Chatmessage[]> {
        let url_ = this.baseUrl + "/api/Chat/GetChatMessages?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(chat);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetChatMessages(_response);
        });
    }

    protected processGetChatMessages(response: AxiosResponse): Promise<Chatmessage[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Chatmessage.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Chatmessage[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Chatmessage[]>(null as any);
    }

    getChatContacts(userId: number | undefined , cancelToken?: CancelToken | undefined): Promise<Chatcontact[]> {
        let url_ = this.baseUrl + "/api/Chat/GetChatContacts?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetChatContacts(_response);
        });
    }

    protected processGetChatContacts(response: AxiosResponse): Promise<Chatcontact[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Chatcontact.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Chatcontact[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Chatcontact[]>(null as any);
    }

    getChatContactByUserId(user1: number | undefined, user2: number | undefined , cancelToken?: CancelToken | undefined): Promise<Chatcontact> {
        let url_ = this.baseUrl + "/api/Chat/GetChatContactByUserId?";
        if (user1 === null)
            throw new Error("The parameter 'user1' cannot be null.");
        else if (user1 !== undefined)
            url_ += "user1=" + encodeURIComponent("" + user1) + "&";
        if (user2 === null)
            throw new Error("The parameter 'user2' cannot be null.");
        else if (user2 !== undefined)
            url_ += "user2=" + encodeURIComponent("" + user2) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetChatContactByUserId(_response);
        });
    }

    protected processGetChatContactByUserId(response: AxiosResponse): Promise<Chatcontact> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Chatcontact.fromJS(resultData200);
            return Promise.resolve<Chatcontact>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Chatcontact>(null as any);
    }

    sendChatMessage(message: Chatmessage , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Chat/SendChatMessages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(message);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendChatMessage(_response);
        });
    }

    protected processSendChatMessage(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export interface IClothesClient {
    getClothesById(id: number | undefined): Promise<ClothesPost>;
}

export class ClothesClient implements IClothesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getClothesById(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<ClothesPost> {
        let url_ = this.baseUrl + "/api/Clothes?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetClothesById(_response);
        });
    }

    protected processGetClothesById(response: AxiosResponse): Promise<ClothesPost> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClothesPost.fromJS(resultData200);
            return Promise.resolve<ClothesPost>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClothesPost>(null as any);
    }
}

export interface INotificationTokenClient {
    getNotificationTokenAll(): Promise<NotificationToken[]>;
    postNotificationToken(notificationToken: NotificationToken): Promise<NotificationToken>;
    getNotificationToken(id: number): Promise<NotificationToken>;
    putNotificationToken(id: number, notificationToken: NotificationToken): Promise<FileResponse>;
    deleteNotificationToken(id: number): Promise<NotificationToken>;
    unSubscribeRemoteNotification(userId: number | undefined): Promise<boolean>;
}

export class NotificationTokenClient implements INotificationTokenClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getNotificationTokenAll(  cancelToken?: CancelToken | undefined): Promise<NotificationToken[]> {
        let url_ = this.baseUrl + "/api/NotificationToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetNotificationTokenAll(_response);
        });
    }

    protected processGetNotificationTokenAll(response: AxiosResponse): Promise<NotificationToken[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationToken.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NotificationToken[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NotificationToken[]>(null as any);
    }

    postNotificationToken(notificationToken: NotificationToken , cancelToken?: CancelToken | undefined): Promise<NotificationToken> {
        let url_ = this.baseUrl + "/api/NotificationToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(notificationToken);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostNotificationToken(_response);
        });
    }

    protected processPostNotificationToken(response: AxiosResponse): Promise<NotificationToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NotificationToken.fromJS(resultData200);
            return Promise.resolve<NotificationToken>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NotificationToken>(null as any);
    }

    getNotificationToken(id: number , cancelToken?: CancelToken | undefined): Promise<NotificationToken> {
        let url_ = this.baseUrl + "/api/NotificationToken/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetNotificationToken(_response);
        });
    }

    protected processGetNotificationToken(response: AxiosResponse): Promise<NotificationToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NotificationToken.fromJS(resultData200);
            return Promise.resolve<NotificationToken>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NotificationToken>(null as any);
    }

    putNotificationToken(id: number, notificationToken: NotificationToken , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/NotificationToken/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(notificationToken);

        let options_: AxiosRequestConfig = {
            data: content_,
            responseType: "blob",
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPutNotificationToken(_response);
        });
    }

    protected processPutNotificationToken(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    deleteNotificationToken(id: number , cancelToken?: CancelToken | undefined): Promise<NotificationToken> {
        let url_ = this.baseUrl + "/api/NotificationToken/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteNotificationToken(_response);
        });
    }

    protected processDeleteNotificationToken(response: AxiosResponse): Promise<NotificationToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NotificationToken.fromJS(resultData200);
            return Promise.resolve<NotificationToken>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NotificationToken>(null as any);
    }

    unSubscribeRemoteNotification(userId: number | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/NotificationToken/UnSubscribeRemoteNotification?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUnSubscribeRemoteNotification(_response);
        });
    }

    protected processUnSubscribeRemoteNotification(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export interface IFileClient {
    uploadFile(folder: string | null | undefined, content: FileRequest): Promise<FileUploadResponse>;
    uploadImages(folder: string | null | undefined, content: string[]): Promise<Filegroup>;
    uploadVideos(folder: string | null | undefined, content: VideoRequest[]): Promise<Filegroup>;
    uploadFileFolder(folder: string | null | undefined, name: string | null | undefined, content: string): Promise<string>;
    uploadRaw(folder: string | null | undefined, name: string | null | undefined, files: any[] | null | undefined): Promise<string>;
    uploadUpdate(folder: string | null | undefined, name: string | null | undefined, files: any[] | null | undefined): Promise<string>;
    getListFolder(): Promise<string[]>;
    getListFiles(folderName: string | null | undefined): Promise<string[]>;
    downloadFile(folder: string | null | undefined, fileName: string | null | undefined): Promise<FileResponse>;
    delete(folder: string | null | undefined, filename: string | null): Promise<void>;
}

export class FileClient implements IFileClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    uploadFile(folder: string | null | undefined, content: FileRequest , cancelToken?: CancelToken | undefined): Promise<FileUploadResponse> {
        let url_ = this.baseUrl + "/api/File/UploadFileString?";
        if (folder !== undefined && folder !== null)
            url_ += "folder=" + encodeURIComponent("" + folder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadFile(_response);
        });
    }

    protected processUploadFile(response: AxiosResponse): Promise<FileUploadResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FileUploadResponse.fromJS(resultData200);
            return Promise.resolve<FileUploadResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileUploadResponse>(null as any);
    }

    uploadImages(folder: string | null | undefined, content: string[] , cancelToken?: CancelToken | undefined): Promise<Filegroup> {
        let url_ = this.baseUrl + "/api/File/UploadImages?";
        if (folder !== undefined && folder !== null)
            url_ += "folder=" + encodeURIComponent("" + folder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadImages(_response);
        });
    }

    protected processUploadImages(response: AxiosResponse): Promise<Filegroup> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Filegroup.fromJS(resultData200);
            return Promise.resolve<Filegroup>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Filegroup>(null as any);
    }

    uploadVideos(folder: string | null | undefined, content: VideoRequest[] , cancelToken?: CancelToken | undefined): Promise<Filegroup> {
        let url_ = this.baseUrl + "/api/File/UploadVideos?";
        if (folder !== undefined && folder !== null)
            url_ += "folder=" + encodeURIComponent("" + folder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadVideos(_response);
        });
    }

    protected processUploadVideos(response: AxiosResponse): Promise<Filegroup> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Filegroup.fromJS(resultData200);
            return Promise.resolve<Filegroup>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Filegroup>(null as any);
    }

    uploadFileFolder(folder: string | null | undefined, name: string | null | undefined, content: string , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/File/UploadFileFolder?";
        if (folder !== undefined && folder !== null)
            url_ += "folder=" + encodeURIComponent("" + folder) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadFileFolder(_response);
        });
    }

    protected processUploadFileFolder(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    uploadRaw(folder: string | null | undefined, name: string | null | undefined, files: any[] | null | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/File/UploadFileRaw?";
        if (folder !== undefined && folder !== null)
            url_ += "folder=" + encodeURIComponent("" + folder) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("files", item_.toString()));

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadRaw(_response);
        });
    }

    protected processUploadRaw(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    uploadUpdate(folder: string | null | undefined, name: string | null | undefined, files: any[] | null | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/File/UploadUpdate?";
        if (folder !== undefined && folder !== null)
            url_ += "folder=" + encodeURIComponent("" + folder) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("files", item_.toString()));

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadUpdate(_response);
        });
    }

    protected processUploadUpdate(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    getListFolder(  cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/File/GetListFolder";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetListFolder(_response);
        });
    }

    protected processGetListFolder(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    getListFiles(folderName: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/File/GetListFiles?";
        if (folderName !== undefined && folderName !== null)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetListFiles(_response);
        });
    }

    protected processGetListFiles(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    downloadFile(folder: string | null | undefined, fileName: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/File/api/File?";
        if (folder !== undefined && folder !== null)
            url_ += "folder=" + encodeURIComponent("" + folder) + "&";
        if (fileName !== undefined && fileName !== null)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadFile(_response);
        });
    }

    protected processDownloadFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    delete(folder: string | null | undefined, filename: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/File/{filename}?";
        if (filename === undefined || filename === null)
            throw new Error("The parameter 'filename' must be defined.");
        url_ = url_.replace("{filename}", encodeURIComponent("" + filename));
        if (folder !== undefined && folder !== null)
            url_ += "folder=" + encodeURIComponent("" + folder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IHomeClient {
    getTopOrder(): Promise<SmallCollectionItemResponse[]>;
    getHotDeal(): Promise<SmallCollectionItemResponse[]>;
    getLoved(): Promise<MediumCollectionItemResponse[]>;
    getInComingOrder(): Promise<InComingOrderResponse[]>;
    getPosts(): Promise<PostResponse[]>;
}

export class HomeClient implements IHomeClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getTopOrder(  cancelToken?: CancelToken | undefined): Promise<SmallCollectionItemResponse[]> {
        let url_ = this.baseUrl + "/api/Home/GetTopOrder";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTopOrder(_response);
        });
    }

    protected processGetTopOrder(response: AxiosResponse): Promise<SmallCollectionItemResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SmallCollectionItemResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SmallCollectionItemResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SmallCollectionItemResponse[]>(null as any);
    }

    getHotDeal(  cancelToken?: CancelToken | undefined): Promise<SmallCollectionItemResponse[]> {
        let url_ = this.baseUrl + "/api/Home/GetHotDeal";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetHotDeal(_response);
        });
    }

    protected processGetHotDeal(response: AxiosResponse): Promise<SmallCollectionItemResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SmallCollectionItemResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SmallCollectionItemResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SmallCollectionItemResponse[]>(null as any);
    }

    getLoved(  cancelToken?: CancelToken | undefined): Promise<MediumCollectionItemResponse[]> {
        let url_ = this.baseUrl + "/api/Home/GetLoved";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLoved(_response);
        });
    }

    protected processGetLoved(response: AxiosResponse): Promise<MediumCollectionItemResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MediumCollectionItemResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MediumCollectionItemResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MediumCollectionItemResponse[]>(null as any);
    }

    getInComingOrder(  cancelToken?: CancelToken | undefined): Promise<InComingOrderResponse[]> {
        let url_ = this.baseUrl + "/api/Home/GetInComingOrder";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetInComingOrder(_response);
        });
    }

    protected processGetInComingOrder(response: AxiosResponse): Promise<InComingOrderResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InComingOrderResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<InComingOrderResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<InComingOrderResponse[]>(null as any);
    }

    getPosts(  cancelToken?: CancelToken | undefined): Promise<PostResponse[]> {
        let url_ = this.baseUrl + "/api/Home/GetPosts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPosts(_response);
        });
    }

    protected processGetPosts(response: AxiosResponse): Promise<PostResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PostResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PostResponse[]>(null as any);
    }
}

export interface IManifestClient {
    getManifest(): Promise<Manifest>;
}

export class ManifestClient implements IManifestClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getManifest(  cancelToken?: CancelToken | undefined): Promise<Manifest> {
        let url_ = this.baseUrl + "/api/Manifest/GetManifest";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetManifest(_response);
        });
    }

    protected processGetManifest(response: AxiosResponse): Promise<Manifest> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Manifest.fromJS(resultData200);
            return Promise.resolve<Manifest>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Manifest>(null as any);
    }
}

export interface INotificationClient {
    getAllNotification(userId: number | undefined): Promise<Notification[]>;
    hasNotification(userId: number | undefined): Promise<boolean>;
    readNotification(id: number | undefined): Promise<Notification>;
    sendGlobalNotification(title: string | null | undefined, message: string | null | undefined): Promise<boolean>;
    getAllNotificationV2(userId: number | undefined): Promise<NotificationResponse[]>;
}

export class NotificationClient implements INotificationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getAllNotification(userId: number | undefined , cancelToken?: CancelToken | undefined): Promise<Notification[]> {
        let url_ = this.baseUrl + "/api/Notification/GetAllNotification?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllNotification(_response);
        });
    }

    protected processGetAllNotification(response: AxiosResponse): Promise<Notification[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Notification.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Notification[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Notification[]>(null as any);
    }

    hasNotification(userId: number | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Notification/HasNotification?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHasNotification(_response);
        });
    }

    protected processHasNotification(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    readNotification(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<Notification> {
        let url_ = this.baseUrl + "/api/Notification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReadNotification(_response);
        });
    }

    protected processReadNotification(response: AxiosResponse): Promise<Notification> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Notification.fromJS(resultData200);
            return Promise.resolve<Notification>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Notification>(null as any);
    }

    sendGlobalNotification(title: string | null | undefined, message: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Notification/SendGlobalNotification?";
        if (title !== undefined && title !== null)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        if (message !== undefined && message !== null)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendGlobalNotification(_response);
        });
    }

    protected processSendGlobalNotification(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    getAllNotificationV2(userId: number | undefined , cancelToken?: CancelToken | undefined): Promise<NotificationResponse[]> {
        let url_ = this.baseUrl + "/api/Notification/GetAllNotificationV2?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllNotificationV2(_response);
        });
    }

    protected processGetAllNotificationV2(response: AxiosResponse): Promise<NotificationResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NotificationResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NotificationResponse[]>(null as any);
    }
}

export interface IPhotographerClient {
    getPhotographerAll(): Promise<PhotographerPost[]>;
    getPhotographer(id: number): Promise<PhotographerPost>;
    getPhotographerServiceById(id: number | undefined): Promise<PhotographerServicePackage[]>;
    getPhotographerPromoCodeById(id: number | undefined): Promise<PGPromoCode[]>;
    getPhotographerPromoCodeByServiceId(id: number | undefined): Promise<PGPromoCode[]>;
}

export class PhotographerClient implements IPhotographerClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getPhotographerAll(  cancelToken?: CancelToken | undefined): Promise<PhotographerPost[]> {
        let url_ = this.baseUrl + "/api/Photographer";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPhotographerAll(_response);
        });
    }

    protected processGetPhotographerAll(response: AxiosResponse): Promise<PhotographerPost[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhotographerPost.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PhotographerPost[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PhotographerPost[]>(null as any);
    }

    getPhotographer(id: number , cancelToken?: CancelToken | undefined): Promise<PhotographerPost> {
        let url_ = this.baseUrl + "/api/Photographer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPhotographer(_response);
        });
    }

    protected processGetPhotographer(response: AxiosResponse): Promise<PhotographerPost> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PhotographerPost.fromJS(resultData200);
            return Promise.resolve<PhotographerPost>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PhotographerPost>(null as any);
    }

    getPhotographerServiceById(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<PhotographerServicePackage[]> {
        let url_ = this.baseUrl + "/api/Photographer/GetPhotographerServiceById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPhotographerServiceById(_response);
        });
    }

    protected processGetPhotographerServiceById(response: AxiosResponse): Promise<PhotographerServicePackage[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhotographerServicePackage.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PhotographerServicePackage[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PhotographerServicePackage[]>(null as any);
    }

    getPhotographerPromoCodeById(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<PGPromoCode[]> {
        let url_ = this.baseUrl + "/api/Photographer/GetPhotographerPromoCodeById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPhotographerPromoCodeById(_response);
        });
    }

    protected processGetPhotographerPromoCodeById(response: AxiosResponse): Promise<PGPromoCode[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PGPromoCode.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PGPromoCode[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PGPromoCode[]>(null as any);
    }

    getPhotographerPromoCodeByServiceId(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<PGPromoCode[]> {
        let url_ = this.baseUrl + "/api/Photographer/GetPhotographerPromoCodeByServiceId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPhotographerPromoCodeByServiceId(_response);
        });
    }

    protected processGetPhotographerPromoCodeByServiceId(response: AxiosResponse): Promise<PGPromoCode[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PGPromoCode.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PGPromoCode[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PGPromoCode[]>(null as any);
    }
}

export interface IPhotographerOrderClient {
    getPhotographerorderAll(): Promise<Photographerorder[]>;
    postPhotographerorder(photographerorder: Photographerorder): Promise<Photographerorder>;
    getPhotographerorder(id: number): Promise<Photographerorder>;
    putPhotographerorder(id: number, photographerorder: Photographerorder): Promise<Photographerorder>;
    deletePhotographerorder(id: number): Promise<Photographerorder>;
    getMyBookingOrder(userId: number | undefined): Promise<Photographerorder[]>;
    getMyPhotographerBookingOrder(userId: number | undefined): Promise<Photographerorder[]>;
    updatePhotographerOrderStatus(photographerorder: Photographerorder): Promise<Photographerorder>;
}

export class PhotographerOrderClient implements IPhotographerOrderClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getPhotographerorderAll(  cancelToken?: CancelToken | undefined): Promise<Photographerorder[]> {
        let url_ = this.baseUrl + "/api/PhotographerOrder";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPhotographerorderAll(_response);
        });
    }

    protected processGetPhotographerorderAll(response: AxiosResponse): Promise<Photographerorder[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Photographerorder.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Photographerorder[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Photographerorder[]>(null as any);
    }

    postPhotographerorder(photographerorder: Photographerorder , cancelToken?: CancelToken | undefined): Promise<Photographerorder> {
        let url_ = this.baseUrl + "/api/PhotographerOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(photographerorder);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostPhotographerorder(_response);
        });
    }

    protected processPostPhotographerorder(response: AxiosResponse): Promise<Photographerorder> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Photographerorder.fromJS(resultData200);
            return Promise.resolve<Photographerorder>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Photographerorder>(null as any);
    }

    getPhotographerorder(id: number , cancelToken?: CancelToken | undefined): Promise<Photographerorder> {
        let url_ = this.baseUrl + "/api/PhotographerOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPhotographerorder(_response);
        });
    }

    protected processGetPhotographerorder(response: AxiosResponse): Promise<Photographerorder> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Photographerorder.fromJS(resultData200);
            return Promise.resolve<Photographerorder>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Photographerorder>(null as any);
    }

    putPhotographerorder(id: number, photographerorder: Photographerorder , cancelToken?: CancelToken | undefined): Promise<Photographerorder> {
        let url_ = this.baseUrl + "/api/PhotographerOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(photographerorder);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPutPhotographerorder(_response);
        });
    }

    protected processPutPhotographerorder(response: AxiosResponse): Promise<Photographerorder> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Photographerorder.fromJS(resultData200);
            return Promise.resolve<Photographerorder>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Photographerorder>(null as any);
    }

    deletePhotographerorder(id: number , cancelToken?: CancelToken | undefined): Promise<Photographerorder> {
        let url_ = this.baseUrl + "/api/PhotographerOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeletePhotographerorder(_response);
        });
    }

    protected processDeletePhotographerorder(response: AxiosResponse): Promise<Photographerorder> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Photographerorder.fromJS(resultData200);
            return Promise.resolve<Photographerorder>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Photographerorder>(null as any);
    }

    getMyBookingOrder(userId: number | undefined , cancelToken?: CancelToken | undefined): Promise<Photographerorder[]> {
        let url_ = this.baseUrl + "/api/PhotographerOrder/GetMyBookingOrder?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMyBookingOrder(_response);
        });
    }

    protected processGetMyBookingOrder(response: AxiosResponse): Promise<Photographerorder[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Photographerorder.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Photographerorder[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Photographerorder[]>(null as any);
    }

    getMyPhotographerBookingOrder(userId: number | undefined , cancelToken?: CancelToken | undefined): Promise<Photographerorder[]> {
        let url_ = this.baseUrl + "/api/PhotographerOrder/GetMyPhotographerBookingOrder?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMyPhotographerBookingOrder(_response);
        });
    }

    protected processGetMyPhotographerBookingOrder(response: AxiosResponse): Promise<Photographerorder[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Photographerorder.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Photographerorder[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Photographerorder[]>(null as any);
    }

    updatePhotographerOrderStatus(photographerorder: Photographerorder , cancelToken?: CancelToken | undefined): Promise<Photographerorder> {
        let url_ = this.baseUrl + "/api/PhotographerOrder/UpdatePhotographerOrderStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(photographerorder);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePhotographerOrderStatus(_response);
        });
    }

    protected processUpdatePhotographerOrderStatus(response: AxiosResponse): Promise<Photographerorder> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Photographerorder.fromJS(resultData200);
            return Promise.resolve<Photographerorder>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Photographerorder>(null as any);
    }
}

export interface IPriceTypeClient {
    getPricetypeAll(): Promise<Pricetype[]>;
    postPricetype(pricetype: Pricetype): Promise<Pricetype>;
    getPricetype(id: number): Promise<Pricetype>;
    putPricetype(id: number, pricetype: Pricetype): Promise<Pricetype>;
    deletePricetype(id: number): Promise<Pricetype>;
}

export class PriceTypeClient implements IPriceTypeClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getPricetypeAll(  cancelToken?: CancelToken | undefined): Promise<Pricetype[]> {
        let url_ = this.baseUrl + "/api/PriceType";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPricetypeAll(_response);
        });
    }

    protected processGetPricetypeAll(response: AxiosResponse): Promise<Pricetype[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Pricetype.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Pricetype[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Pricetype[]>(null as any);
    }

    postPricetype(pricetype: Pricetype , cancelToken?: CancelToken | undefined): Promise<Pricetype> {
        let url_ = this.baseUrl + "/api/PriceType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pricetype);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostPricetype(_response);
        });
    }

    protected processPostPricetype(response: AxiosResponse): Promise<Pricetype> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Pricetype.fromJS(resultData200);
            return Promise.resolve<Pricetype>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Pricetype>(null as any);
    }

    getPricetype(id: number , cancelToken?: CancelToken | undefined): Promise<Pricetype> {
        let url_ = this.baseUrl + "/api/PriceType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPricetype(_response);
        });
    }

    protected processGetPricetype(response: AxiosResponse): Promise<Pricetype> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Pricetype.fromJS(resultData200);
            return Promise.resolve<Pricetype>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Pricetype>(null as any);
    }

    putPricetype(id: number, pricetype: Pricetype , cancelToken?: CancelToken | undefined): Promise<Pricetype> {
        let url_ = this.baseUrl + "/api/PriceType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pricetype);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPutPricetype(_response);
        });
    }

    protected processPutPricetype(response: AxiosResponse): Promise<Pricetype> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Pricetype.fromJS(resultData200);
            return Promise.resolve<Pricetype>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Pricetype>(null as any);
    }

    deletePricetype(id: number , cancelToken?: CancelToken | undefined): Promise<Pricetype> {
        let url_ = this.baseUrl + "/api/PriceType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeletePricetype(_response);
        });
    }

    protected processDeletePricetype(response: AxiosResponse): Promise<Pricetype> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Pricetype.fromJS(resultData200);
            return Promise.resolve<Pricetype>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Pricetype>(null as any);
    }
}

export interface IProfileClient {
    updateUserInfo(user: User): Promise<User>;
    getTotalInformation(user: User): Promise<User>;
    getTotalInfor(id: number | undefined): Promise<User>;
}

export class ProfileClient implements IProfileClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    updateUserInfo(user: User , cancelToken?: CancelToken | undefined): Promise<User> {
        let url_ = this.baseUrl + "/api/Profile/UpdateUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateUserInfo(_response);
        });
    }

    protected processUpdateUserInfo(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return Promise.resolve<User>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(null as any);
    }

    getTotalInformation(user: User , cancelToken?: CancelToken | undefined): Promise<User> {
        let url_ = this.baseUrl + "/api/Profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTotalInformation(_response);
        });
    }

    protected processGetTotalInformation(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return Promise.resolve<User>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(null as any);
    }

    getTotalInfor(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<User> {
        let url_ = this.baseUrl + "/api/Profile/GetTotalInfor?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTotalInfor(_response);
        });
    }

    protected processGetTotalInfor(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return Promise.resolve<User>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(null as any);
    }
}

export interface IResourcesClient {
    getResources(): Promise<ResourceDataResponse[]>;
}

export class ResourcesClient implements IResourcesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getResources(  cancelToken?: CancelToken | undefined): Promise<ResourceDataResponse[]> {
        let url_ = this.baseUrl + "/api/Resources";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetResources(_response);
        });
    }

    protected processGetResources(response: AxiosResponse): Promise<ResourceDataResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResourceDataResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ResourceDataResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResourceDataResponse[]>(null as any);
    }
}

export interface ISearchClient {
    search(request: SearchRequest): Promise<MediumCollectionItemResponse[]>;
}

export class SearchClient implements ISearchClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    search(request: SearchRequest , cancelToken?: CancelToken | undefined): Promise<MediumCollectionItemResponse[]> {
        let url_ = this.baseUrl + "/api/Search/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<MediumCollectionItemResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MediumCollectionItemResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MediumCollectionItemResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MediumCollectionItemResponse[]>(null as any);
    }
}

export interface IServicepackClient {
    getServicepackAll(): Promise<Servicepack[]>;
    postServicepack(servicepack: Servicepack): Promise<Servicepack>;
    getServicepack(id: number): Promise<Servicepack>;
    putServicepack(id: number, servicepack: Servicepack): Promise<Servicepack>;
    deleteServicepack(id: number): Promise<Servicepack>;
}

export class ServicepackClient implements IServicepackClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getServicepackAll(  cancelToken?: CancelToken | undefined): Promise<Servicepack[]> {
        let url_ = this.baseUrl + "/api/Servicepack";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServicepackAll(_response);
        });
    }

    protected processGetServicepackAll(response: AxiosResponse): Promise<Servicepack[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Servicepack.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Servicepack[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Servicepack[]>(null as any);
    }

    postServicepack(servicepack: Servicepack , cancelToken?: CancelToken | undefined): Promise<Servicepack> {
        let url_ = this.baseUrl + "/api/Servicepack";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(servicepack);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostServicepack(_response);
        });
    }

    protected processPostServicepack(response: AxiosResponse): Promise<Servicepack> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Servicepack.fromJS(resultData200);
            return Promise.resolve<Servicepack>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Servicepack>(null as any);
    }

    getServicepack(id: number , cancelToken?: CancelToken | undefined): Promise<Servicepack> {
        let url_ = this.baseUrl + "/api/Servicepack/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServicepack(_response);
        });
    }

    protected processGetServicepack(response: AxiosResponse): Promise<Servicepack> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Servicepack.fromJS(resultData200);
            return Promise.resolve<Servicepack>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Servicepack>(null as any);
    }

    putServicepack(id: number, servicepack: Servicepack , cancelToken?: CancelToken | undefined): Promise<Servicepack> {
        let url_ = this.baseUrl + "/api/Servicepack/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(servicepack);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPutServicepack(_response);
        });
    }

    protected processPutServicepack(response: AxiosResponse): Promise<Servicepack> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Servicepack.fromJS(resultData200);
            return Promise.resolve<Servicepack>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Servicepack>(null as any);
    }

    deleteServicepack(id: number , cancelToken?: CancelToken | undefined): Promise<Servicepack> {
        let url_ = this.baseUrl + "/api/Servicepack/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteServicepack(_response);
        });
    }

    protected processDeleteServicepack(response: AxiosResponse): Promise<Servicepack> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Servicepack.fromJS(resultData200);
            return Promise.resolve<Servicepack>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Servicepack>(null as any);
    }
}

export interface IServicepackpriceClient {
    getServicepackpriceAll(): Promise<Servicepackprice[]>;
    postServicepackprice(servicepackprice: Servicepackprice): Promise<Servicepackprice>;
    getServicepackprice(id: number): Promise<Servicepackprice>;
    putServicepackprice(id: number, servicepackprice: Servicepackprice): Promise<Servicepackprice>;
    deleteServicepackprice(id: number): Promise<Servicepackprice>;
}

export class ServicepackpriceClient implements IServicepackpriceClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getServicepackpriceAll(  cancelToken?: CancelToken | undefined): Promise<Servicepackprice[]> {
        let url_ = this.baseUrl + "/api/Servicepackprice";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServicepackpriceAll(_response);
        });
    }

    protected processGetServicepackpriceAll(response: AxiosResponse): Promise<Servicepackprice[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Servicepackprice.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Servicepackprice[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Servicepackprice[]>(null as any);
    }

    postServicepackprice(servicepackprice: Servicepackprice , cancelToken?: CancelToken | undefined): Promise<Servicepackprice> {
        let url_ = this.baseUrl + "/api/Servicepackprice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(servicepackprice);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostServicepackprice(_response);
        });
    }

    protected processPostServicepackprice(response: AxiosResponse): Promise<Servicepackprice> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Servicepackprice.fromJS(resultData200);
            return Promise.resolve<Servicepackprice>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Servicepackprice>(null as any);
    }

    getServicepackprice(id: number , cancelToken?: CancelToken | undefined): Promise<Servicepackprice> {
        let url_ = this.baseUrl + "/api/Servicepackprice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServicepackprice(_response);
        });
    }

    protected processGetServicepackprice(response: AxiosResponse): Promise<Servicepackprice> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Servicepackprice.fromJS(resultData200);
            return Promise.resolve<Servicepackprice>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Servicepackprice>(null as any);
    }

    putServicepackprice(id: number, servicepackprice: Servicepackprice , cancelToken?: CancelToken | undefined): Promise<Servicepackprice> {
        let url_ = this.baseUrl + "/api/Servicepackprice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(servicepackprice);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPutServicepackprice(_response);
        });
    }

    protected processPutServicepackprice(response: AxiosResponse): Promise<Servicepackprice> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Servicepackprice.fromJS(resultData200);
            return Promise.resolve<Servicepackprice>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Servicepackprice>(null as any);
    }

    deleteServicepackprice(id: number , cancelToken?: CancelToken | undefined): Promise<Servicepackprice> {
        let url_ = this.baseUrl + "/api/Servicepackprice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteServicepackprice(_response);
        });
    }

    protected processDeleteServicepackprice(response: AxiosResponse): Promise<Servicepackprice> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Servicepackprice.fromJS(resultData200);
            return Promise.resolve<Servicepackprice>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Servicepackprice>(null as any);
    }
}

export interface IServicepaymenttypeClient {
    getServicepaymenttypeAll(): Promise<Servicepaymenttype[]>;
    postServicepaymenttype(servicepaymenttype: Servicepaymenttype): Promise<Servicepaymenttype>;
    getServicepaymenttype(id: number): Promise<Servicepaymenttype>;
    putServicepaymenttype(id: number, servicepaymenttype: Servicepaymenttype): Promise<Servicepaymenttype>;
    deleteServicepaymenttype(id: number): Promise<Servicepaymenttype>;
}

export class ServicepaymenttypeClient implements IServicepaymenttypeClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getServicepaymenttypeAll(  cancelToken?: CancelToken | undefined): Promise<Servicepaymenttype[]> {
        let url_ = this.baseUrl + "/api/Servicepaymenttype";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServicepaymenttypeAll(_response);
        });
    }

    protected processGetServicepaymenttypeAll(response: AxiosResponse): Promise<Servicepaymenttype[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Servicepaymenttype.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Servicepaymenttype[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Servicepaymenttype[]>(null as any);
    }

    postServicepaymenttype(servicepaymenttype: Servicepaymenttype , cancelToken?: CancelToken | undefined): Promise<Servicepaymenttype> {
        let url_ = this.baseUrl + "/api/Servicepaymenttype";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(servicepaymenttype);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostServicepaymenttype(_response);
        });
    }

    protected processPostServicepaymenttype(response: AxiosResponse): Promise<Servicepaymenttype> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Servicepaymenttype.fromJS(resultData200);
            return Promise.resolve<Servicepaymenttype>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Servicepaymenttype>(null as any);
    }

    getServicepaymenttype(id: number , cancelToken?: CancelToken | undefined): Promise<Servicepaymenttype> {
        let url_ = this.baseUrl + "/api/Servicepaymenttype/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServicepaymenttype(_response);
        });
    }

    protected processGetServicepaymenttype(response: AxiosResponse): Promise<Servicepaymenttype> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Servicepaymenttype.fromJS(resultData200);
            return Promise.resolve<Servicepaymenttype>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Servicepaymenttype>(null as any);
    }

    putServicepaymenttype(id: number, servicepaymenttype: Servicepaymenttype , cancelToken?: CancelToken | undefined): Promise<Servicepaymenttype> {
        let url_ = this.baseUrl + "/api/Servicepaymenttype/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(servicepaymenttype);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPutServicepaymenttype(_response);
        });
    }

    protected processPutServicepaymenttype(response: AxiosResponse): Promise<Servicepaymenttype> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Servicepaymenttype.fromJS(resultData200);
            return Promise.resolve<Servicepaymenttype>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Servicepaymenttype>(null as any);
    }

    deleteServicepaymenttype(id: number , cancelToken?: CancelToken | undefined): Promise<Servicepaymenttype> {
        let url_ = this.baseUrl + "/api/Servicepaymenttype/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteServicepaymenttype(_response);
        });
    }

    protected processDeleteServicepaymenttype(response: AxiosResponse): Promise<Servicepaymenttype> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Servicepaymenttype.fromJS(resultData200);
            return Promise.resolve<Servicepaymenttype>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Servicepaymenttype>(null as any);
    }
}

export interface ISpecialdayClient {
    getSpecialdayAll(): Promise<Specialday[]>;
    postSpecialday(specialday: Specialday): Promise<Specialday>;
    getSpecialday(id: number): Promise<Specialday>;
    putSpecialday(id: number, specialday: Specialday): Promise<Specialday>;
    deleteSpecialday(id: number): Promise<Specialday>;
}

export class SpecialdayClient implements ISpecialdayClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getSpecialdayAll(  cancelToken?: CancelToken | undefined): Promise<Specialday[]> {
        let url_ = this.baseUrl + "/api/Specialday";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSpecialdayAll(_response);
        });
    }

    protected processGetSpecialdayAll(response: AxiosResponse): Promise<Specialday[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Specialday.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Specialday[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Specialday[]>(null as any);
    }

    postSpecialday(specialday: Specialday , cancelToken?: CancelToken | undefined): Promise<Specialday> {
        let url_ = this.baseUrl + "/api/Specialday";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(specialday);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostSpecialday(_response);
        });
    }

    protected processPostSpecialday(response: AxiosResponse): Promise<Specialday> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Specialday.fromJS(resultData200);
            return Promise.resolve<Specialday>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Specialday>(null as any);
    }

    getSpecialday(id: number , cancelToken?: CancelToken | undefined): Promise<Specialday> {
        let url_ = this.baseUrl + "/api/Specialday/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSpecialday(_response);
        });
    }

    protected processGetSpecialday(response: AxiosResponse): Promise<Specialday> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Specialday.fromJS(resultData200);
            return Promise.resolve<Specialday>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Specialday>(null as any);
    }

    putSpecialday(id: number, specialday: Specialday , cancelToken?: CancelToken | undefined): Promise<Specialday> {
        let url_ = this.baseUrl + "/api/Specialday/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(specialday);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPutSpecialday(_response);
        });
    }

    protected processPutSpecialday(response: AxiosResponse): Promise<Specialday> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Specialday.fromJS(resultData200);
            return Promise.resolve<Specialday>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Specialday>(null as any);
    }

    deleteSpecialday(id: number , cancelToken?: CancelToken | undefined): Promise<Specialday> {
        let url_ = this.baseUrl + "/api/Specialday/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteSpecialday(_response);
        });
    }

    protected processDeleteSpecialday(response: AxiosResponse): Promise<Specialday> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Specialday.fromJS(resultData200);
            return Promise.resolve<Specialday>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Specialday>(null as any);
    }
}

export interface IStaticFileClient {
    getImage(id: string | undefined): Promise<FileResponse>;
    getVideo(id: string | undefined): Promise<FileResponse>;
    getResource(id: string | null | undefined): Promise<FileResponse>;
    webHookStaticFile(): Promise<FileResponse>;
}

export class StaticFileClient implements IStaticFileClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getImage(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/StaticFile/GetImage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetImage(_response);
        });
    }

    protected processGetImage(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getVideo(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/StaticFile/GetVideo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetVideo(_response);
        });
    }

    protected processGetVideo(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getResource(id: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/StaticFile/GetResource?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetResource(_response);
        });
    }

    protected processGetResource(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    webHookStaticFile(  cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/StaticFile/WebHookStaticFile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWebHookStaticFile(_response);
        });
    }

    protected processWebHookStaticFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IStudioClient {
    getStudioPostAll(): Promise<StudioPost[]>;
    getStudioRating(studioId: number | undefined): Promise<StudioRatingResponse[]>;
    getStudioPost(id: number): Promise<StudioPost>;
    getStudioRoomsByStudioId(id: number | undefined): Promise<StudioRoom[]>;
    getStudioPromoCodeByStudioId(id: number | undefined): Promise<PromoCode[]>;
    getStudioPromoCodeByStudioRoomId(id: number | undefined): Promise<PromoCode[]>;
    bookingStudioRoom(booking: StudioBooking): Promise<StudioBooking>;
    uploadBookingEvidence(request: UploadEvidenceImageRequest): Promise<StudioBooking>;
}

export class StudioClient implements IStudioClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    getStudioPostAll(  cancelToken?: CancelToken | undefined): Promise<StudioPost[]> {
        let url_ = this.baseUrl + "/api/Studio";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStudioPostAll(_response);
        });
    }

    protected processGetStudioPostAll(response: AxiosResponse): Promise<StudioPost[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StudioPost.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<StudioPost[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StudioPost[]>(null as any);
    }

    getStudioRating(studioId: number | undefined , cancelToken?: CancelToken | undefined): Promise<StudioRatingResponse[]> {
        let url_ = this.baseUrl + "/api/Studio?";
        if (studioId === null)
            throw new Error("The parameter 'studioId' cannot be null.");
        else if (studioId !== undefined)
            url_ += "studioId=" + encodeURIComponent("" + studioId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStudioRating(_response);
        });
    }

    protected processGetStudioRating(response: AxiosResponse): Promise<StudioRatingResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StudioRatingResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<StudioRatingResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StudioRatingResponse[]>(null as any);
    }

    getStudioPost(id: number , cancelToken?: CancelToken | undefined): Promise<StudioPost> {
        let url_ = this.baseUrl + "/api/Studio/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStudioPost(_response);
        });
    }

    protected processGetStudioPost(response: AxiosResponse): Promise<StudioPost> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StudioPost.fromJS(resultData200);
            return Promise.resolve<StudioPost>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StudioPost>(null as any);
    }

    getStudioRoomsByStudioId(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<StudioRoom[]> {
        let url_ = this.baseUrl + "/api/Studio/GetStudioRoomsByStudioId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStudioRoomsByStudioId(_response);
        });
    }

    protected processGetStudioRoomsByStudioId(response: AxiosResponse): Promise<StudioRoom[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StudioRoom.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<StudioRoom[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StudioRoom[]>(null as any);
    }

    getStudioPromoCodeByStudioId(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<PromoCode[]> {
        let url_ = this.baseUrl + "/api/Studio/GetStudioPromoCodeByStudioId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStudioPromoCodeByStudioId(_response);
        });
    }

    protected processGetStudioPromoCodeByStudioId(response: AxiosResponse): Promise<PromoCode[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PromoCode.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PromoCode[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PromoCode[]>(null as any);
    }

    getStudioPromoCodeByStudioRoomId(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<PromoCode[]> {
        let url_ = this.baseUrl + "/api/Studio/GetStudioPromoCodeByStudioRoomId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStudioPromoCodeByStudioRoomId(_response);
        });
    }

    protected processGetStudioPromoCodeByStudioRoomId(response: AxiosResponse): Promise<PromoCode[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PromoCode.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PromoCode[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PromoCode[]>(null as any);
    }

    bookingStudioRoom(booking: StudioBooking , cancelToken?: CancelToken | undefined): Promise<StudioBooking> {
        let url_ = this.baseUrl + "/api/Studio/BookingStudioRoom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(booking);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBookingStudioRoom(_response);
        });
    }

    protected processBookingStudioRoom(response: AxiosResponse): Promise<StudioBooking> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StudioBooking.fromJS(resultData200);
            return Promise.resolve<StudioBooking>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StudioBooking>(null as any);
    }

    uploadBookingEvidence(request: UploadEvidenceImageRequest , cancelToken?: CancelToken | undefined): Promise<StudioBooking> {
        let url_ = this.baseUrl + "/api/Studio/UploadBookingEvidence";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadBookingEvidence(_response);
        });
    }

    protected processUploadBookingEvidence(response: AxiosResponse): Promise<StudioBooking> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StudioBooking.fromJS(resultData200);
            return Promise.resolve<StudioBooking>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StudioBooking>(null as any);
    }
}

export interface IUsersClient {
    checkExistPhone(phone: string | null | undefined): Promise<boolean>;
    register(user: UserRegisterRequest): Promise<UserResponse>;
    loginExistPhone(phone: string | null | undefined): Promise<UserResponse>;
    changePassword(user: UserChangePasswordRequest): Promise<UserChangePasswordResponse>;
}

export class UsersClient implements IUsersClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    checkExistPhone(phone: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Users/CheckExistPhone?";
        if (phone !== undefined && phone !== null)
            url_ += "phone=" + encodeURIComponent("" + phone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckExistPhone(_response);
        });
    }

    protected processCheckExistPhone(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    register(user: UserRegisterRequest , cancelToken?: CancelToken | undefined): Promise<UserResponse> {
        let url_ = this.baseUrl + "/api/Users/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: AxiosResponse): Promise<UserResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserResponse.fromJS(resultData200);
            return Promise.resolve<UserResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserResponse>(null as any);
    }

    loginExistPhone(phone: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<UserResponse> {
        let url_ = this.baseUrl + "/api/Users/LoginExistPhone?";
        if (phone !== undefined && phone !== null)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLoginExistPhone(_response);
        });
    }

    protected processLoginExistPhone(response: AxiosResponse): Promise<UserResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserResponse.fromJS(resultData200);
            return Promise.resolve<UserResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserResponse>(null as any);
    }

    changePassword(user: UserChangePasswordRequest , cancelToken?: CancelToken | undefined): Promise<UserChangePasswordResponse> {
        let url_ = this.baseUrl + "/api/Users/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: AxiosResponse): Promise<UserChangePasswordResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserChangePasswordResponse.fromJS(resultData200);
            return Promise.resolve<UserChangePasswordResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserChangePasswordResponse>(null as any);
    }
}

export interface IVerifyClient {
    verifyLogin(): Promise<boolean>;
}

export class VerifyClient implements IVerifyClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bookingstudio.vn";

    }

    verifyLogin(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Verify";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerifyLogin(_response);
        });
    }

    protected processVerifyLogin(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export abstract class EntityOfInteger implements IEntityOfInteger {
    id?: number;

    constructor(data?: IEntityOfInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
        }
    }

    static fromJS(data: any): EntityOfInteger {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'EntityOfInteger' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        return data;
    }
}

export interface IEntityOfInteger {
    id?: number;
}

export abstract class Entity extends EntityOfInteger implements IEntity {

    constructor(data?: IEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): Entity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Entity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IEntity extends IEntityOfInteger {
}

export class Province extends Entity implements IProvince {
    name?: string | undefined;
    code?: string | undefined;

    constructor(data?: IProvince) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["Name"];
            this.code = _data["Code"];
        }
    }

    static fromJS(data: any): Province {
        data = typeof data === 'object' ? data : {};
        let result = new Province();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Code"] = this.code;
        super.toJSON(data);
        return data;
    }
}

export interface IProvince extends IEntity {
    name?: string | undefined;
    code?: string | undefined;
}

export class District extends Entity implements IDistrict {
    name?: string | undefined;
    prefix?: string | undefined;
    provinceId?: number;
    provinceFk?: Province | undefined;

    constructor(data?: IDistrict) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["Name"];
            this.prefix = _data["Prefix"];
            this.provinceId = _data["ProvinceId"];
            this.provinceFk = _data["ProvinceFk"] ? Province.fromJS(_data["ProvinceFk"]) : <any>undefined;
        }
    }

    static fromJS(data: any): District {
        data = typeof data === 'object' ? data : {};
        let result = new District();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Prefix"] = this.prefix;
        data["ProvinceId"] = this.provinceId;
        data["ProvinceFk"] = this.provinceFk ? this.provinceFk.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IDistrict extends IEntity {
    name?: string | undefined;
    prefix?: string | undefined;
    provinceId?: number;
    provinceFk?: Province | undefined;
}

export class Ward extends Entity implements IWard {
    name?: string | undefined;
    prefix?: string | undefined;
    districtId?: number | undefined;
    districtFk?: District | undefined;
    provinceId?: number | undefined;
    provinceFk?: Province | undefined;

    constructor(data?: IWard) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["Name"];
            this.prefix = _data["Prefix"];
            this.districtId = _data["DistrictId"];
            this.districtFk = _data["DistrictFk"] ? District.fromJS(_data["DistrictFk"]) : <any>undefined;
            this.provinceId = _data["ProvinceId"];
            this.provinceFk = _data["ProvinceFk"] ? Province.fromJS(_data["ProvinceFk"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Ward {
        data = typeof data === 'object' ? data : {};
        let result = new Ward();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Prefix"] = this.prefix;
        data["DistrictId"] = this.districtId;
        data["DistrictFk"] = this.districtFk ? this.districtFk.toJSON() : <any>undefined;
        data["ProvinceId"] = this.provinceId;
        data["ProvinceFk"] = this.provinceFk ? this.provinceFk.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IWard extends IEntity {
    name?: string | undefined;
    prefix?: string | undefined;
    districtId?: number | undefined;
    districtFk?: District | undefined;
    provinceId?: number | undefined;
    provinceFk?: Province | undefined;
}

export class Album implements IAlbum {
    fileImages?: Uploadfile[] | undefined;
    fileVideos?: Uploadfile[] | undefined;
    id?: number;
    owner?: number;
    name?: string | undefined;
    imagegroupid?: number | undefined;
    videogroupid?: number | undefined;
    createddate?: Date | undefined;
    updateddate?: Date | undefined;

    constructor(data?: IAlbum) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["FileImages"])) {
                this.fileImages = [] as any;
                for (let item of _data["FileImages"])
                    this.fileImages!.push(Uploadfile.fromJS(item));
            }
            if (Array.isArray(_data["FileVideos"])) {
                this.fileVideos = [] as any;
                for (let item of _data["FileVideos"])
                    this.fileVideos!.push(Uploadfile.fromJS(item));
            }
            this.id = _data["Id"];
            this.owner = _data["Owner"];
            this.name = _data["Name"];
            this.imagegroupid = _data["Imagegroupid"];
            this.videogroupid = _data["Videogroupid"];
            this.createddate = _data["Createddate"] ? new Date(_data["Createddate"].toString()) : <any>undefined;
            this.updateddate = _data["Updateddate"] ? new Date(_data["Updateddate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Album {
        data = typeof data === 'object' ? data : {};
        let result = new Album();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fileImages)) {
            data["FileImages"] = [];
            for (let item of this.fileImages)
                data["FileImages"].push(item.toJSON());
        }
        if (Array.isArray(this.fileVideos)) {
            data["FileVideos"] = [];
            for (let item of this.fileVideos)
                data["FileVideos"].push(item.toJSON());
        }
        data["Id"] = this.id;
        data["Owner"] = this.owner;
        data["Name"] = this.name;
        data["Imagegroupid"] = this.imagegroupid;
        data["Videogroupid"] = this.videogroupid;
        data["Createddate"] = this.createddate ? this.createddate.toISOString() : <any>undefined;
        data["Updateddate"] = this.updateddate ? this.updateddate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAlbum {
    fileImages?: Uploadfile[] | undefined;
    fileVideos?: Uploadfile[] | undefined;
    id?: number;
    owner?: number;
    name?: string | undefined;
    imagegroupid?: number | undefined;
    videogroupid?: number | undefined;
    createddate?: Date | undefined;
    updateddate?: Date | undefined;
}

export class Uploadfile implements IUploadfile {
    id?: number;
    path?: string | undefined;
    thumnailpath?: string | undefined;
    name?: string | undefined;
    size?: number | undefined;
    extension?: string | undefined;
    filegroupid?: number;
    createddate?: Date | undefined;
    updateddate?: Date | undefined;

    constructor(data?: IUploadfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.path = _data["Path"];
            this.thumnailpath = _data["Thumnailpath"];
            this.name = _data["Name"];
            this.size = _data["Size"];
            this.extension = _data["Extension"];
            this.filegroupid = _data["Filegroupid"];
            this.createddate = _data["Createddate"] ? new Date(_data["Createddate"].toString()) : <any>undefined;
            this.updateddate = _data["Updateddate"] ? new Date(_data["Updateddate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Uploadfile {
        data = typeof data === 'object' ? data : {};
        let result = new Uploadfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Path"] = this.path;
        data["Thumnailpath"] = this.thumnailpath;
        data["Name"] = this.name;
        data["Size"] = this.size;
        data["Extension"] = this.extension;
        data["Filegroupid"] = this.filegroupid;
        data["Createddate"] = this.createddate ? this.createddate.toISOString() : <any>undefined;
        data["Updateddate"] = this.updateddate ? this.updateddate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUploadfile {
    id?: number;
    path?: string | undefined;
    thumnailpath?: string | undefined;
    name?: string | undefined;
    size?: number | undefined;
    extension?: string | undefined;
    filegroupid?: number;
    createddate?: Date | undefined;
    updateddate?: Date | undefined;
}

export class LoginAdminResponse implements ILoginAdminResponse {
    id?: number;
    token?: string | undefined;
    usertype?: number;
    email?: string | undefined;
    username?: string | undefined;
    phone?: string | undefined;
    companyname?: string | undefined;
    fullname?: string | undefined;
    experience?: string | undefined;
    website?: string | undefined;

    constructor(data?: ILoginAdminResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.token = _data["Token"];
            this.usertype = _data["Usertype"];
            this.email = _data["Email"];
            this.username = _data["Username"];
            this.phone = _data["Phone"];
            this.companyname = _data["Companyname"];
            this.fullname = _data["Fullname"];
            this.experience = _data["Experience"];
            this.website = _data["Website"];
        }
    }

    static fromJS(data: any): LoginAdminResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginAdminResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Token"] = this.token;
        data["Usertype"] = this.usertype;
        data["Email"] = this.email;
        data["Username"] = this.username;
        data["Phone"] = this.phone;
        data["Companyname"] = this.companyname;
        data["Fullname"] = this.fullname;
        data["Experience"] = this.experience;
        data["Website"] = this.website;
        return data;
    }
}

export interface ILoginAdminResponse {
    id?: number;
    token?: string | undefined;
    usertype?: number;
    email?: string | undefined;
    username?: string | undefined;
    phone?: string | undefined;
    companyname?: string | undefined;
    fullname?: string | undefined;
    experience?: string | undefined;
    website?: string | undefined;
}

export class LoginAdminRequest implements ILoginAdminRequest {
    username?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginAdminRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["Username"];
            this.password = _data["Password"];
        }
    }

    static fromJS(data: any): LoginAdminRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginAdminRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Username"] = this.username;
        data["Password"] = this.password;
        return data;
    }
}

export interface ILoginAdminRequest {
    username?: string | undefined;
    password?: string | undefined;
}

export class UserResponse implements IUserResponse {
    accessToken?: string | undefined;
    expireDate?: Date;
    description?: string | undefined;
    id?: number;
    usertype?: number;
    email?: string | undefined;
    username?: string | undefined;
    phone?: string | undefined;
    fullname?: string | undefined;
    createddate?: Date;
    updateddate?: Date;
    status?: number | undefined;
    updatedby?: number | undefined;
    imageurl?: string | undefined;
    facebookid?: string | undefined;
    googleemail?: string | undefined;
    facebooktoken?: string | undefined;
    facebookfirstname?: string | undefined;
    facebooklastname?: string | undefined;
    facebookemail?: string | undefined;
    facebookpicture?: string | undefined;
    googlename?: string | undefined;
    googlepicture?: string | undefined;
    appleUserIdentifier?: string | undefined;
    appleGivenName?: string | undefined;
    appleFamilyName?: string | undefined;
    appleEmail?: string | undefined;

    constructor(data?: IUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["AccessToken"];
            this.expireDate = _data["ExpireDate"] ? new Date(_data["ExpireDate"].toString()) : <any>undefined;
            this.description = _data["Description"];
            this.id = _data["Id"];
            this.usertype = _data["Usertype"];
            this.email = _data["Email"];
            this.username = _data["Username"];
            this.phone = _data["Phone"];
            this.fullname = _data["Fullname"];
            this.createddate = _data["Createddate"] ? new Date(_data["Createddate"].toString()) : <any>undefined;
            this.updateddate = _data["Updateddate"] ? new Date(_data["Updateddate"].toString()) : <any>undefined;
            this.status = _data["Status"];
            this.updatedby = _data["Updatedby"];
            this.imageurl = _data["Imageurl"];
            this.facebookid = _data["Facebookid"];
            this.googleemail = _data["Googleemail"];
            this.facebooktoken = _data["Facebooktoken"];
            this.facebookfirstname = _data["Facebookfirstname"];
            this.facebooklastname = _data["Facebooklastname"];
            this.facebookemail = _data["Facebookemail"];
            this.facebookpicture = _data["Facebookpicture"];
            this.googlename = _data["Googlename"];
            this.googlepicture = _data["Googlepicture"];
            this.appleUserIdentifier = _data["AppleUserIdentifier"];
            this.appleGivenName = _data["AppleGivenName"];
            this.appleFamilyName = _data["AppleFamilyName"];
            this.appleEmail = _data["AppleEmail"];
        }
    }

    static fromJS(data: any): UserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AccessToken"] = this.accessToken;
        data["ExpireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["Description"] = this.description;
        data["Id"] = this.id;
        data["Usertype"] = this.usertype;
        data["Email"] = this.email;
        data["Username"] = this.username;
        data["Phone"] = this.phone;
        data["Fullname"] = this.fullname;
        data["Createddate"] = this.createddate ? this.createddate.toISOString() : <any>undefined;
        data["Updateddate"] = this.updateddate ? this.updateddate.toISOString() : <any>undefined;
        data["Status"] = this.status;
        data["Updatedby"] = this.updatedby;
        data["Imageurl"] = this.imageurl;
        data["Facebookid"] = this.facebookid;
        data["Googleemail"] = this.googleemail;
        data["Facebooktoken"] = this.facebooktoken;
        data["Facebookfirstname"] = this.facebookfirstname;
        data["Facebooklastname"] = this.facebooklastname;
        data["Facebookemail"] = this.facebookemail;
        data["Facebookpicture"] = this.facebookpicture;
        data["Googlename"] = this.googlename;
        data["Googlepicture"] = this.googlepicture;
        data["AppleUserIdentifier"] = this.appleUserIdentifier;
        data["AppleGivenName"] = this.appleGivenName;
        data["AppleFamilyName"] = this.appleFamilyName;
        data["AppleEmail"] = this.appleEmail;
        return data;
    }
}

export interface IUserResponse {
    accessToken?: string | undefined;
    expireDate?: Date;
    description?: string | undefined;
    id?: number;
    usertype?: number;
    email?: string | undefined;
    username?: string | undefined;
    phone?: string | undefined;
    fullname?: string | undefined;
    createddate?: Date;
    updateddate?: Date;
    status?: number | undefined;
    updatedby?: number | undefined;
    imageurl?: string | undefined;
    facebookid?: string | undefined;
    googleemail?: string | undefined;
    facebooktoken?: string | undefined;
    facebookfirstname?: string | undefined;
    facebooklastname?: string | undefined;
    facebookemail?: string | undefined;
    facebookpicture?: string | undefined;
    googlename?: string | undefined;
    googlepicture?: string | undefined;
    appleUserIdentifier?: string | undefined;
    appleGivenName?: string | undefined;
    appleFamilyName?: string | undefined;
    appleEmail?: string | undefined;
}

export class LoginRequest implements ILoginRequest {
    phone?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["Phone"];
            this.password = _data["Password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Phone"] = this.phone;
        data["Password"] = this.password;
        return data;
    }
}

export interface ILoginRequest {
    phone?: string | undefined;
    password?: string | undefined;
}

export class FacebookRequest implements IFacebookRequest {
    id?: string | undefined;
    token?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    picture?: string | undefined;

    constructor(data?: IFacebookRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.token = _data["Token"];
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.email = _data["Email"];
            this.picture = _data["Picture"];
        }
    }

    static fromJS(data: any): FacebookRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Token"] = this.token;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["Email"] = this.email;
        data["Picture"] = this.picture;
        return data;
    }
}

export interface IFacebookRequest {
    id?: string | undefined;
    token?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    picture?: string | undefined;
}

export class GoogleRequest implements IGoogleRequest {
    name?: string | undefined;
    email?: string | undefined;
    picture?: string | undefined;

    constructor(data?: IGoogleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.email = _data["Email"];
            this.picture = _data["Picture"];
        }
    }

    static fromJS(data: any): GoogleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Email"] = this.email;
        data["Picture"] = this.picture;
        return data;
    }
}

export interface IGoogleRequest {
    name?: string | undefined;
    email?: string | undefined;
    picture?: string | undefined;
}

export class AppleLoginRequest implements IAppleLoginRequest {
    userIdentifier?: string | undefined;
    givenName?: string | undefined;
    familyName?: string | undefined;
    email?: string | undefined;

    constructor(data?: IAppleLoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userIdentifier = _data["UserIdentifier"];
            this.givenName = _data["GivenName"];
            this.familyName = _data["FamilyName"];
            this.email = _data["Email"];
        }
    }

    static fromJS(data: any): AppleLoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AppleLoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserIdentifier"] = this.userIdentifier;
        data["GivenName"] = this.givenName;
        data["FamilyName"] = this.familyName;
        data["Email"] = this.email;
        return data;
    }
}

export interface IAppleLoginRequest {
    userIdentifier?: string | undefined;
    givenName?: string | undefined;
    familyName?: string | undefined;
    email?: string | undefined;
}

export abstract class CreationAuditedEntityOfInteger extends EntityOfInteger implements ICreationAuditedEntityOfInteger {
    creationTime?: Date;
    creatorUserId?: number | undefined;

    constructor(data?: ICreationAuditedEntityOfInteger) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.creationTime = _data["CreationTime"] ? new Date(_data["CreationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["CreatorUserId"];
        }
    }

    static fromJS(data: any): CreationAuditedEntityOfInteger {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CreationAuditedEntityOfInteger' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CreationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["CreatorUserId"] = this.creatorUserId;
        super.toJSON(data);
        return data;
    }
}

export interface ICreationAuditedEntityOfInteger extends IEntityOfInteger {
    creationTime?: Date;
    creatorUserId?: number | undefined;
}

export abstract class AuditedEntityOfInteger extends CreationAuditedEntityOfInteger implements IAuditedEntityOfInteger {
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;

    constructor(data?: IAuditedEntityOfInteger) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.lastModificationTime = _data["LastModificationTime"] ? new Date(_data["LastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["LastModifierUserId"];
        }
    }

    static fromJS(data: any): AuditedEntityOfInteger {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditedEntityOfInteger' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["LastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["LastModifierUserId"] = this.lastModifierUserId;
        super.toJSON(data);
        return data;
    }
}

export interface IAuditedEntityOfInteger extends ICreationAuditedEntityOfInteger {
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
}

export abstract class FullAuditedEntityOfInteger extends AuditedEntityOfInteger implements IFullAuditedEntityOfInteger {
    isDeleted?: boolean;
    deleterUserId?: number | undefined;
    deletionTime?: Date | undefined;

    constructor(data?: IFullAuditedEntityOfInteger) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isDeleted = _data["IsDeleted"];
            this.deleterUserId = _data["DeleterUserId"];
            this.deletionTime = _data["DeletionTime"] ? new Date(_data["DeletionTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FullAuditedEntityOfInteger {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'FullAuditedEntityOfInteger' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsDeleted"] = this.isDeleted;
        data["DeleterUserId"] = this.deleterUserId;
        data["DeletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IFullAuditedEntityOfInteger extends IAuditedEntityOfInteger {
    isDeleted?: boolean;
    deleterUserId?: number | undefined;
    deletionTime?: Date | undefined;
}

export abstract class FullAuditedEntity extends FullAuditedEntityOfInteger implements IFullAuditedEntity {

    constructor(data?: IFullAuditedEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): FullAuditedEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'FullAuditedEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IFullAuditedEntity extends IFullAuditedEntityOfInteger {
}

export class RegisterPartner extends FullAuditedEntity implements IRegisterPartner {
    partnerName!: string;
    representativeName!: string;
    phone!: string;
    otherPhone?: string | undefined;
    email!: string;
    reEmail!: string;
    businessRegistrationLicenseNumber?: string | undefined;
    address!: string;
    bankBranchName?: string | undefined;
    bankAccount?: string | undefined;
    bankAccountOwnerName?: string | undefined;
    autoGeneratedPassword!: string;
    businessType?: string | undefined;
    personalIdentity?: string | undefined;

    constructor(data?: IRegisterPartner) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.partnerName = _data["PartnerName"];
            this.representativeName = _data["RepresentativeName"];
            this.phone = _data["Phone"];
            this.otherPhone = _data["OtherPhone"];
            this.email = _data["Email"];
            this.reEmail = _data["ReEmail"];
            this.businessRegistrationLicenseNumber = _data["BusinessRegistrationLicenseNumber"];
            this.address = _data["Address"];
            this.bankBranchName = _data["BankBranchName"];
            this.bankAccount = _data["BankAccount"];
            this.bankAccountOwnerName = _data["BankAccountOwnerName"];
            this.autoGeneratedPassword = _data["AutoGeneratedPassword"];
            this.businessType = _data["BusinessType"];
            this.personalIdentity = _data["PersonalIdentity"];
        }
    }

    static fromJS(data: any): RegisterPartner {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterPartner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PartnerName"] = this.partnerName;
        data["RepresentativeName"] = this.representativeName;
        data["Phone"] = this.phone;
        data["OtherPhone"] = this.otherPhone;
        data["Email"] = this.email;
        data["ReEmail"] = this.reEmail;
        data["BusinessRegistrationLicenseNumber"] = this.businessRegistrationLicenseNumber;
        data["Address"] = this.address;
        data["BankBranchName"] = this.bankBranchName;
        data["BankAccount"] = this.bankAccount;
        data["BankAccountOwnerName"] = this.bankAccountOwnerName;
        data["AutoGeneratedPassword"] = this.autoGeneratedPassword;
        data["BusinessType"] = this.businessType;
        data["PersonalIdentity"] = this.personalIdentity;
        super.toJSON(data);
        return data;
    }
}

export interface IRegisterPartner extends IFullAuditedEntity {
    partnerName: string;
    representativeName: string;
    phone: string;
    otherPhone?: string | undefined;
    email: string;
    reEmail: string;
    businessRegistrationLicenseNumber?: string | undefined;
    address: string;
    bankBranchName?: string | undefined;
    bankAccount?: string | undefined;
    bankAccountOwnerName?: string | undefined;
    autoGeneratedPassword: string;
    businessType?: string | undefined;
    personalIdentity?: string | undefined;
}

export class Chatmessage implements IChatmessage {
    isMine?: boolean;
    id?: number;
    message?: string | undefined;
    chatcontactid?: number;
    messagetype?: number;
    time?: Date;

    constructor(data?: IChatmessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isMine = _data["IsMine"];
            this.id = _data["Id"];
            this.message = _data["Message"];
            this.chatcontactid = _data["Chatcontactid"];
            this.messagetype = _data["Messagetype"];
            this.time = _data["Time"] ? new Date(_data["Time"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Chatmessage {
        data = typeof data === 'object' ? data : {};
        let result = new Chatmessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsMine"] = this.isMine;
        data["Id"] = this.id;
        data["Message"] = this.message;
        data["Chatcontactid"] = this.chatcontactid;
        data["Messagetype"] = this.messagetype;
        data["Time"] = this.time ? this.time.toISOString() : <any>undefined;
        return data;
    }
}

export interface IChatmessage {
    isMine?: boolean;
    id?: number;
    message?: string | undefined;
    chatcontactid?: number;
    messagetype?: number;
    time?: Date;
}

export class Chatcontact implements IChatcontact {
    user1Name?: string | undefined;
    user1Image?: string | undefined;
    user2Name?: string | undefined;
    user2Image?: string | undefined;
    id?: number;
    user1?: number;
    user2?: number;
    createddate?: Date;
    lastchatmessage?: string | undefined;
    lastchattime?: Date | undefined;

    constructor(data?: IChatcontact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user1Name = _data["User1Name"];
            this.user1Image = _data["User1Image"];
            this.user2Name = _data["User2Name"];
            this.user2Image = _data["User2Image"];
            this.id = _data["Id"];
            this.user1 = _data["User1"];
            this.user2 = _data["User2"];
            this.createddate = _data["Createddate"] ? new Date(_data["Createddate"].toString()) : <any>undefined;
            this.lastchatmessage = _data["Lastchatmessage"];
            this.lastchattime = _data["Lastchattime"] ? new Date(_data["Lastchattime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Chatcontact {
        data = typeof data === 'object' ? data : {};
        let result = new Chatcontact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["User1Name"] = this.user1Name;
        data["User1Image"] = this.user1Image;
        data["User2Name"] = this.user2Name;
        data["User2Image"] = this.user2Image;
        data["Id"] = this.id;
        data["User1"] = this.user1;
        data["User2"] = this.user2;
        data["Createddate"] = this.createddate ? this.createddate.toISOString() : <any>undefined;
        data["Lastchatmessage"] = this.lastchatmessage;
        data["Lastchattime"] = this.lastchattime ? this.lastchattime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IChatcontact {
    user1Name?: string | undefined;
    user1Image?: string | undefined;
    user2Name?: string | undefined;
    user2Image?: string | undefined;
    id?: number;
    user1?: number;
    user2?: number;
    createddate?: Date;
    lastchatmessage?: string | undefined;
    lastchattime?: Date | undefined;
}

export class ClothesPost extends FullAuditedEntity implements IClothesPost {
    tenantId?: number | undefined;
    name!: string;
    description!: string;
    bookingCount?: number;
    price?: number;
    sales?: number;
    image1?: string | undefined;
    image2?: string | undefined;
    image3?: string | undefined;
    image4?: string | undefined;
    image5?: string | undefined;
    image6?: string | undefined;
    image7?: string | undefined;
    image8?: string | undefined;
    image9?: string | undefined;
    image10?: string | undefined;
    image11?: string | undefined;
    image12?: string | undefined;
    image13?: string | undefined;
    image14?: string | undefined;
    image15?: string | undefined;
    image16?: string | undefined;
    image17?: string | undefined;
    image18?: string | undefined;
    image19?: string | undefined;
    image20?: string | undefined;
    isPopular?: boolean;
    isBestSell?: boolean;
    isNewest?: boolean;
    address?: string | undefined;
    shopId?: number | undefined;
    shopFk?: Shop | undefined;

    constructor(data?: IClothesPost) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tenantId = _data["TenantId"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.bookingCount = _data["BookingCount"];
            this.price = _data["Price"];
            this.sales = _data["Sales"];
            this.image1 = _data["Image1"];
            this.image2 = _data["Image2"];
            this.image3 = _data["Image3"];
            this.image4 = _data["Image4"];
            this.image5 = _data["Image5"];
            this.image6 = _data["Image6"];
            this.image7 = _data["Image7"];
            this.image8 = _data["Image8"];
            this.image9 = _data["Image9"];
            this.image10 = _data["Image10"];
            this.image11 = _data["Image11"];
            this.image12 = _data["Image12"];
            this.image13 = _data["Image13"];
            this.image14 = _data["Image14"];
            this.image15 = _data["Image15"];
            this.image16 = _data["Image16"];
            this.image17 = _data["Image17"];
            this.image18 = _data["Image18"];
            this.image19 = _data["Image19"];
            this.image20 = _data["Image20"];
            this.isPopular = _data["IsPopular"];
            this.isBestSell = _data["IsBestSell"];
            this.isNewest = _data["IsNewest"];
            this.address = _data["Address"];
            this.shopId = _data["ShopId"];
            this.shopFk = _data["ShopFk"] ? Shop.fromJS(_data["ShopFk"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClothesPost {
        data = typeof data === 'object' ? data : {};
        let result = new ClothesPost();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantId"] = this.tenantId;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["BookingCount"] = this.bookingCount;
        data["Price"] = this.price;
        data["Sales"] = this.sales;
        data["Image1"] = this.image1;
        data["Image2"] = this.image2;
        data["Image3"] = this.image3;
        data["Image4"] = this.image4;
        data["Image5"] = this.image5;
        data["Image6"] = this.image6;
        data["Image7"] = this.image7;
        data["Image8"] = this.image8;
        data["Image9"] = this.image9;
        data["Image10"] = this.image10;
        data["Image11"] = this.image11;
        data["Image12"] = this.image12;
        data["Image13"] = this.image13;
        data["Image14"] = this.image14;
        data["Image15"] = this.image15;
        data["Image16"] = this.image16;
        data["Image17"] = this.image17;
        data["Image18"] = this.image18;
        data["Image19"] = this.image19;
        data["Image20"] = this.image20;
        data["IsPopular"] = this.isPopular;
        data["IsBestSell"] = this.isBestSell;
        data["IsNewest"] = this.isNewest;
        data["Address"] = this.address;
        data["ShopId"] = this.shopId;
        data["ShopFk"] = this.shopFk ? this.shopFk.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IClothesPost extends IFullAuditedEntity {
    tenantId?: number | undefined;
    name: string;
    description: string;
    bookingCount?: number;
    price?: number;
    sales?: number;
    image1?: string | undefined;
    image2?: string | undefined;
    image3?: string | undefined;
    image4?: string | undefined;
    image5?: string | undefined;
    image6?: string | undefined;
    image7?: string | undefined;
    image8?: string | undefined;
    image9?: string | undefined;
    image10?: string | undefined;
    image11?: string | undefined;
    image12?: string | undefined;
    image13?: string | undefined;
    image14?: string | undefined;
    image15?: string | undefined;
    image16?: string | undefined;
    image17?: string | undefined;
    image18?: string | undefined;
    image19?: string | undefined;
    image20?: string | undefined;
    isPopular?: boolean;
    isBestSell?: boolean;
    isNewest?: boolean;
    address?: string | undefined;
    shopId?: number | undefined;
    shopFk?: Shop | undefined;
}

export class Shop extends FullAuditedEntity implements IShop {
    tenantId?: number | undefined;
    name!: string;
    address?: string | undefined;
    latitude?: number;
    longtitude?: number;
    description?: string | undefined;
    isAuthorized?: boolean;
    avatar?: string | undefined;
    hourCloseDefault?: number;
    hourOpenDefault?: number;
    minutesCloseDefault?: number;
    minutesOpenDefault?: number;
    isHotDeal?: boolean;
    bookingUserId?: number | undefined;
    bookingUserFk?: BookingUser | undefined;

    constructor(data?: IShop) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tenantId = _data["TenantId"];
            this.name = _data["Name"];
            this.address = _data["Address"];
            this.latitude = _data["Latitude"];
            this.longtitude = _data["Longtitude"];
            this.description = _data["Description"];
            this.isAuthorized = _data["IsAuthorized"];
            this.avatar = _data["Avatar"];
            this.hourCloseDefault = _data["HourCloseDefault"];
            this.hourOpenDefault = _data["HourOpenDefault"];
            this.minutesCloseDefault = _data["MinutesCloseDefault"];
            this.minutesOpenDefault = _data["MinutesOpenDefault"];
            this.isHotDeal = _data["IsHotDeal"];
            this.bookingUserId = _data["BookingUserId"];
            this.bookingUserFk = _data["BookingUserFk"] ? BookingUser.fromJS(_data["BookingUserFk"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Shop {
        data = typeof data === 'object' ? data : {};
        let result = new Shop();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantId"] = this.tenantId;
        data["Name"] = this.name;
        data["Address"] = this.address;
        data["Latitude"] = this.latitude;
        data["Longtitude"] = this.longtitude;
        data["Description"] = this.description;
        data["IsAuthorized"] = this.isAuthorized;
        data["Avatar"] = this.avatar;
        data["HourCloseDefault"] = this.hourCloseDefault;
        data["HourOpenDefault"] = this.hourOpenDefault;
        data["MinutesCloseDefault"] = this.minutesCloseDefault;
        data["MinutesOpenDefault"] = this.minutesOpenDefault;
        data["IsHotDeal"] = this.isHotDeal;
        data["BookingUserId"] = this.bookingUserId;
        data["BookingUserFk"] = this.bookingUserFk ? this.bookingUserFk.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IShop extends IFullAuditedEntity {
    tenantId?: number | undefined;
    name: string;
    address?: string | undefined;
    latitude?: number;
    longtitude?: number;
    description?: string | undefined;
    isAuthorized?: boolean;
    avatar?: string | undefined;
    hourCloseDefault?: number;
    hourOpenDefault?: number;
    minutesCloseDefault?: number;
    minutesOpenDefault?: number;
    isHotDeal?: boolean;
    bookingUserId?: number | undefined;
    bookingUserFk?: BookingUser | undefined;
}

export class BookingUser extends FullAuditedEntity implements IBookingUser {
    email!: string;
    username?: string | undefined;
    phone?: string | undefined;
    hashPassword?: string | undefined;
    salt?: string | undefined;
    fullname?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    status?: number;
    updatedBy?: number;
    image?: string | undefined;
    facebookId?: string | undefined;
    googleEmail?: string | undefined;
    facebookToken?: string | undefined;
    facebookFirstname?: string | undefined;
    facebookLastname?: string | undefined;
    facebookEmail?: string | undefined;
    facebookPicture?: string | undefined;
    googleName?: string | undefined;
    googlePicture?: string | undefined;
    appleUserIdentifier?: string | undefined;
    appleGivenName?: string | undefined;
    appleFamilyName?: string | undefined;
    appleEmail?: string | undefined;
    userTypeId?: number | undefined;
    userTypeFk?: UserType | undefined;

    constructor(data?: IBookingUser) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.email = _data["Email"];
            this.username = _data["Username"];
            this.phone = _data["Phone"];
            this.hashPassword = _data["HashPassword"];
            this.salt = _data["Salt"];
            this.fullname = _data["Fullname"];
            this.createdDate = _data["CreatedDate"] ? new Date(_data["CreatedDate"].toString()) : <any>undefined;
            this.updatedDate = _data["UpdatedDate"] ? new Date(_data["UpdatedDate"].toString()) : <any>undefined;
            this.status = _data["Status"];
            this.updatedBy = _data["UpdatedBy"];
            this.image = _data["Image"];
            this.facebookId = _data["FacebookId"];
            this.googleEmail = _data["GoogleEmail"];
            this.facebookToken = _data["FacebookToken"];
            this.facebookFirstname = _data["FacebookFirstname"];
            this.facebookLastname = _data["FacebookLastname"];
            this.facebookEmail = _data["FacebookEmail"];
            this.facebookPicture = _data["FacebookPicture"];
            this.googleName = _data["GoogleName"];
            this.googlePicture = _data["GooglePicture"];
            this.appleUserIdentifier = _data["AppleUserIdentifier"];
            this.appleGivenName = _data["AppleGivenName"];
            this.appleFamilyName = _data["AppleFamilyName"];
            this.appleEmail = _data["AppleEmail"];
            this.userTypeId = _data["UserTypeId"];
            this.userTypeFk = _data["UserTypeFk"] ? UserType.fromJS(_data["UserTypeFk"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BookingUser {
        data = typeof data === 'object' ? data : {};
        let result = new BookingUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Email"] = this.email;
        data["Username"] = this.username;
        data["Phone"] = this.phone;
        data["HashPassword"] = this.hashPassword;
        data["Salt"] = this.salt;
        data["Fullname"] = this.fullname;
        data["CreatedDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["UpdatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["Status"] = this.status;
        data["UpdatedBy"] = this.updatedBy;
        data["Image"] = this.image;
        data["FacebookId"] = this.facebookId;
        data["GoogleEmail"] = this.googleEmail;
        data["FacebookToken"] = this.facebookToken;
        data["FacebookFirstname"] = this.facebookFirstname;
        data["FacebookLastname"] = this.facebookLastname;
        data["FacebookEmail"] = this.facebookEmail;
        data["FacebookPicture"] = this.facebookPicture;
        data["GoogleName"] = this.googleName;
        data["GooglePicture"] = this.googlePicture;
        data["AppleUserIdentifier"] = this.appleUserIdentifier;
        data["AppleGivenName"] = this.appleGivenName;
        data["AppleFamilyName"] = this.appleFamilyName;
        data["AppleEmail"] = this.appleEmail;
        data["UserTypeId"] = this.userTypeId;
        data["UserTypeFk"] = this.userTypeFk ? this.userTypeFk.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IBookingUser extends IFullAuditedEntity {
    email: string;
    username?: string | undefined;
    phone?: string | undefined;
    hashPassword?: string | undefined;
    salt?: string | undefined;
    fullname?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
    status?: number;
    updatedBy?: number;
    image?: string | undefined;
    facebookId?: string | undefined;
    googleEmail?: string | undefined;
    facebookToken?: string | undefined;
    facebookFirstname?: string | undefined;
    facebookLastname?: string | undefined;
    facebookEmail?: string | undefined;
    facebookPicture?: string | undefined;
    googleName?: string | undefined;
    googlePicture?: string | undefined;
    appleUserIdentifier?: string | undefined;
    appleGivenName?: string | undefined;
    appleFamilyName?: string | undefined;
    appleEmail?: string | undefined;
    userTypeId?: number | undefined;
    userTypeFk?: UserType | undefined;
}

export class UserType extends FullAuditedEntity implements IUserType {
    name?: string | undefined;

    constructor(data?: IUserType) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["Name"];
        }
    }

    static fromJS(data: any): UserType {
        data = typeof data === 'object' ? data : {};
        let result = new UserType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        super.toJSON(data);
        return data;
    }
}

export interface IUserType extends IFullAuditedEntity {
    name?: string | undefined;
}

export class NotificationToken extends Entity implements INotificationToken {
    userId?: number;
    token!: string;

    constructor(data?: INotificationToken) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["UserId"];
            this.token = _data["Token"];
        }
    }

    static fromJS(data: any): NotificationToken {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["Token"] = this.token;
        super.toJSON(data);
        return data;
    }
}

export interface INotificationToken extends IEntity {
    userId?: number;
    token: string;
}

export class FileUploadResponse implements IFileUploadResponse {
    fileUploadId?: number;
    url?: string | undefined;

    constructor(data?: IFileUploadResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileUploadId = _data["FileUploadId"];
            this.url = _data["Url"];
        }
    }

    static fromJS(data: any): FileUploadResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FileUploadResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FileUploadId"] = this.fileUploadId;
        data["Url"] = this.url;
        return data;
    }
}

export interface IFileUploadResponse {
    fileUploadId?: number;
    url?: string | undefined;
}

export class FileRequest implements IFileRequest {
    data?: string | undefined;

    constructor(data?: IFileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["Data"];
        }
    }

    static fromJS(data: any): FileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Data"] = this.data;
        return data;
    }
}

export interface IFileRequest {
    data?: string | undefined;
}

export class Filegroup implements IFilegroup {
    id?: number;
    type?: string | undefined;
    createddate?: Date | undefined;
    updateddate?: Date | undefined;

    constructor(data?: IFilegroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.type = _data["Type"];
            this.createddate = _data["Createddate"] ? new Date(_data["Createddate"].toString()) : <any>undefined;
            this.updateddate = _data["Updateddate"] ? new Date(_data["Updateddate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Filegroup {
        data = typeof data === 'object' ? data : {};
        let result = new Filegroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Type"] = this.type;
        data["Createddate"] = this.createddate ? this.createddate.toISOString() : <any>undefined;
        data["Updateddate"] = this.updateddate ? this.updateddate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IFilegroup {
    id?: number;
    type?: string | undefined;
    createddate?: Date | undefined;
    updateddate?: Date | undefined;
}

export class VideoRequest implements IVideoRequest {
    contentBase64?: string | undefined;
    thumbnailBase64?: string | undefined;

    constructor(data?: IVideoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentBase64 = _data["ContentBase64"];
            this.thumbnailBase64 = _data["ThumbnailBase64"];
        }
    }

    static fromJS(data: any): VideoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VideoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ContentBase64"] = this.contentBase64;
        data["ThumbnailBase64"] = this.thumbnailBase64;
        return data;
    }
}

export interface IVideoRequest {
    contentBase64?: string | undefined;
    thumbnailBase64?: string | undefined;
}

export class SmallCollectionItemResponse implements ISmallCollectionItemResponse {
    image?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    price?: number;
    isLove?: boolean;
    type?: PostType;
    id?: number;
    bookingCount?: number;

    constructor(data?: ISmallCollectionItemResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.image = _data["Image"];
            this.name = _data["Name"];
            this.address = _data["Address"];
            this.price = _data["Price"];
            this.isLove = _data["IsLove"];
            this.type = _data["Type"];
            this.id = _data["Id"];
            this.bookingCount = _data["BookingCount"];
        }
    }

    static fromJS(data: any): SmallCollectionItemResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SmallCollectionItemResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Image"] = this.image;
        data["Name"] = this.name;
        data["Address"] = this.address;
        data["Price"] = this.price;
        data["IsLove"] = this.isLove;
        data["Type"] = this.type;
        data["Id"] = this.id;
        data["BookingCount"] = this.bookingCount;
        return data;
    }
}

export interface ISmallCollectionItemResponse {
    image?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    price?: number;
    isLove?: boolean;
    type?: PostType;
    id?: number;
    bookingCount?: number;
}

export enum PostType {
    Studio = 1,
    Photographer = 2,
    Device = 3,
    Clothes = 4,
    Makeup = 5,
    Model = 6,
}

export class MediumCollectionItemResponse implements IMediumCollectionItemResponse {
    id?: number;
    image1?: string | undefined;
    image2?: string | undefined;
    image3?: string | undefined;
    isloved?: boolean;
    address?: string | undefined;
    name?: string | undefined;
    price?: number;
    priceUnit?: string | undefined;
    rate?: number;
    totalRate?: number;
    type?: PostType;
    bookingCount?: number;
    isAuthorized?: boolean;
    createdDate?: Date;

    constructor(data?: IMediumCollectionItemResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.image1 = _data["Image1"];
            this.image2 = _data["Image2"];
            this.image3 = _data["Image3"];
            this.isloved = _data["Isloved"];
            this.address = _data["Address"];
            this.name = _data["Name"];
            this.price = _data["Price"];
            this.priceUnit = _data["PriceUnit"];
            this.rate = _data["Rate"];
            this.totalRate = _data["TotalRate"];
            this.type = _data["Type"];
            this.bookingCount = _data["BookingCount"];
            this.isAuthorized = _data["IsAuthorized"];
            this.createdDate = _data["CreatedDate"] ? new Date(_data["CreatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MediumCollectionItemResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MediumCollectionItemResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Image1"] = this.image1;
        data["Image2"] = this.image2;
        data["Image3"] = this.image3;
        data["Isloved"] = this.isloved;
        data["Address"] = this.address;
        data["Name"] = this.name;
        data["Price"] = this.price;
        data["PriceUnit"] = this.priceUnit;
        data["Rate"] = this.rate;
        data["TotalRate"] = this.totalRate;
        data["Type"] = this.type;
        data["BookingCount"] = this.bookingCount;
        data["IsAuthorized"] = this.isAuthorized;
        data["CreatedDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IMediumCollectionItemResponse {
    id?: number;
    image1?: string | undefined;
    image2?: string | undefined;
    image3?: string | undefined;
    isloved?: boolean;
    address?: string | undefined;
    name?: string | undefined;
    price?: number;
    priceUnit?: string | undefined;
    rate?: number;
    totalRate?: number;
    type?: PostType;
    bookingCount?: number;
    isAuthorized?: boolean;
    createdDate?: Date;
}

export class InComingOrderResponse implements IInComingOrderResponse {
    image?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    price?: number;
    isLove?: boolean;
    type?: number;
    status?: string | undefined;
    dateString?: string | undefined;
    fromTime?: string | undefined;
    fromTimeLabel?: string | undefined;
    toTime?: string | undefined;
    toTimeLabel?: string | undefined;
    paymentType?: string | undefined;
    verify?: string | undefined;
    orderName?: string | undefined;

    constructor(data?: IInComingOrderResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.image = _data["Image"];
            this.name = _data["Name"];
            this.address = _data["Address"];
            this.price = _data["Price"];
            this.isLove = _data["IsLove"];
            this.type = _data["Type"];
            this.status = _data["Status"];
            this.dateString = _data["DateString"];
            this.fromTime = _data["FromTime"];
            this.fromTimeLabel = _data["FromTimeLabel"];
            this.toTime = _data["ToTime"];
            this.toTimeLabel = _data["ToTimeLabel"];
            this.paymentType = _data["PaymentType"];
            this.verify = _data["Verify"];
            this.orderName = _data["OrderName"];
        }
    }

    static fromJS(data: any): InComingOrderResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InComingOrderResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Image"] = this.image;
        data["Name"] = this.name;
        data["Address"] = this.address;
        data["Price"] = this.price;
        data["IsLove"] = this.isLove;
        data["Type"] = this.type;
        data["Status"] = this.status;
        data["DateString"] = this.dateString;
        data["FromTime"] = this.fromTime;
        data["FromTimeLabel"] = this.fromTimeLabel;
        data["ToTime"] = this.toTime;
        data["ToTimeLabel"] = this.toTimeLabel;
        data["PaymentType"] = this.paymentType;
        data["Verify"] = this.verify;
        data["OrderName"] = this.orderName;
        return data;
    }
}

export interface IInComingOrderResponse {
    image?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    price?: number;
    isLove?: boolean;
    type?: number;
    status?: string | undefined;
    dateString?: string | undefined;
    fromTime?: string | undefined;
    fromTimeLabel?: string | undefined;
    toTime?: string | undefined;
    toTimeLabel?: string | undefined;
    paymentType?: string | undefined;
    verify?: string | undefined;
    orderName?: string | undefined;
}

export class PostResponse implements IPostResponse {
    tags?: string | undefined;
    description?: string | undefined;
    image1?: string | undefined;
    image2?: string | undefined;
    image3?: string | undefined;
    image4?: string | undefined;
    image5?: string | undefined;
    image6?: string | undefined;
    totalLikes?: number;
    totalComments?: number;
    bookingUserId?: number;
    postUserAvatar?: string | undefined;
    postUserName?: string | undefined;
    creationTime?: Date;

    constructor(data?: IPostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tags = _data["Tags"];
            this.description = _data["Description"];
            this.image1 = _data["Image1"];
            this.image2 = _data["Image2"];
            this.image3 = _data["Image3"];
            this.image4 = _data["Image4"];
            this.image5 = _data["Image5"];
            this.image6 = _data["Image6"];
            this.totalLikes = _data["TotalLikes"];
            this.totalComments = _data["TotalComments"];
            this.bookingUserId = _data["BookingUserId"];
            this.postUserAvatar = _data["PostUserAvatar"];
            this.postUserName = _data["PostUserName"];
            this.creationTime = _data["CreationTime"] ? new Date(_data["CreationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Tags"] = this.tags;
        data["Description"] = this.description;
        data["Image1"] = this.image1;
        data["Image2"] = this.image2;
        data["Image3"] = this.image3;
        data["Image4"] = this.image4;
        data["Image5"] = this.image5;
        data["Image6"] = this.image6;
        data["TotalLikes"] = this.totalLikes;
        data["TotalComments"] = this.totalComments;
        data["BookingUserId"] = this.bookingUserId;
        data["PostUserAvatar"] = this.postUserAvatar;
        data["PostUserName"] = this.postUserName;
        data["CreationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPostResponse {
    tags?: string | undefined;
    description?: string | undefined;
    image1?: string | undefined;
    image2?: string | undefined;
    image3?: string | undefined;
    image4?: string | undefined;
    image5?: string | undefined;
    image6?: string | undefined;
    totalLikes?: number;
    totalComments?: number;
    bookingUserId?: number;
    postUserAvatar?: string | undefined;
    postUserName?: string | undefined;
    creationTime?: Date;
}

export class Manifest extends FullAuditedEntity implements IManifest {
    urlDebug?: string | undefined;
    urlRelease?: string | undefined;

    constructor(data?: IManifest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.urlDebug = _data["UrlDebug"];
            this.urlRelease = _data["UrlRelease"];
        }
    }

    static fromJS(data: any): Manifest {
        data = typeof data === 'object' ? data : {};
        let result = new Manifest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UrlDebug"] = this.urlDebug;
        data["UrlRelease"] = this.urlRelease;
        super.toJSON(data);
        return data;
    }
}

export interface IManifest extends IFullAuditedEntity {
    urlDebug?: string | undefined;
    urlRelease?: string | undefined;
}

export class Notification extends Entity implements INotification {
    resourceKey!: string;
    param1?: string | undefined;
    paramId1?: number;
    param2?: string | undefined;
    paramId2?: number;
    image?: string | undefined;
    publishDate?: Date | undefined;
    userId?: number;
    isRead?: boolean;

    constructor(data?: INotification) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.resourceKey = _data["ResourceKey"];
            this.param1 = _data["Param1"];
            this.paramId1 = _data["ParamId1"];
            this.param2 = _data["Param2"];
            this.paramId2 = _data["ParamId2"];
            this.image = _data["Image"];
            this.publishDate = _data["PublishDate"] ? new Date(_data["PublishDate"].toString()) : <any>undefined;
            this.userId = _data["UserId"];
            this.isRead = _data["IsRead"];
        }
    }

    static fromJS(data: any): Notification {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ResourceKey"] = this.resourceKey;
        data["Param1"] = this.param1;
        data["ParamId1"] = this.paramId1;
        data["Param2"] = this.param2;
        data["ParamId2"] = this.paramId2;
        data["Image"] = this.image;
        data["PublishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>undefined;
        data["UserId"] = this.userId;
        data["IsRead"] = this.isRead;
        super.toJSON(data);
        return data;
    }
}

export interface INotification extends IEntity {
    resourceKey: string;
    param1?: string | undefined;
    paramId1?: number;
    param2?: string | undefined;
    paramId2?: number;
    image?: string | undefined;
    publishDate?: Date | undefined;
    userId?: number;
    isRead?: boolean;
}

export class NotificationResponse implements INotificationResponse {
    header?: string | undefined;
    content?: string | undefined;
    date?: string | undefined;
    isRead?: boolean;
    notificationId?: number;
    imageUrl?: string | undefined;

    constructor(data?: INotificationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["Header"];
            this.content = _data["Content"];
            this.date = _data["Date"];
            this.isRead = _data["IsRead"];
            this.notificationId = _data["NotificationId"];
            this.imageUrl = _data["ImageUrl"];
        }
    }

    static fromJS(data: any): NotificationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Header"] = this.header;
        data["Content"] = this.content;
        data["Date"] = this.date;
        data["IsRead"] = this.isRead;
        data["NotificationId"] = this.notificationId;
        data["ImageUrl"] = this.imageUrl;
        return data;
    }
}

export interface INotificationResponse {
    header?: string | undefined;
    content?: string | undefined;
    date?: string | undefined;
    isRead?: boolean;
    notificationId?: number;
    imageUrl?: string | undefined;
}

export class PhotographerPost extends FullAuditedEntity implements IPhotographerPost {
    tenantId?: number | undefined;
    name!: string;
    address?: string | undefined;
    price?: number;
    sales?: number;
    bookingCount?: number;
    description?: string | undefined;
    image1?: string | undefined;
    image2?: string | undefined;
    image3?: string | undefined;
    image4?: string | undefined;
    image5?: string | undefined;
    image6?: string | undefined;
    image7?: string | undefined;
    image8?: string | undefined;
    image9?: string | undefined;
    image10?: string | undefined;
    image11?: string | undefined;
    image12?: string | undefined;
    image13?: string | undefined;
    image14?: string | undefined;
    image15?: string | undefined;
    image16?: string | undefined;
    image17?: string | undefined;
    image18?: string | undefined;
    image19?: string | undefined;
    image20?: string | undefined;
    hourOpenDefault?: number;
    minutesOpenDefault?: number;
    hourCloseDefault?: number;
    minutesCloseDefault?: number;
    isHotDeal?: boolean;
    priceUnit?: string | undefined;

    constructor(data?: IPhotographerPost) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tenantId = _data["TenantId"];
            this.name = _data["Name"];
            this.address = _data["Address"];
            this.price = _data["Price"];
            this.sales = _data["Sales"];
            this.bookingCount = _data["BookingCount"];
            this.description = _data["Description"];
            this.image1 = _data["Image1"];
            this.image2 = _data["Image2"];
            this.image3 = _data["Image3"];
            this.image4 = _data["Image4"];
            this.image5 = _data["Image5"];
            this.image6 = _data["Image6"];
            this.image7 = _data["Image7"];
            this.image8 = _data["Image8"];
            this.image9 = _data["Image9"];
            this.image10 = _data["Image10"];
            this.image11 = _data["Image11"];
            this.image12 = _data["Image12"];
            this.image13 = _data["Image13"];
            this.image14 = _data["Image14"];
            this.image15 = _data["Image15"];
            this.image16 = _data["Image16"];
            this.image17 = _data["Image17"];
            this.image18 = _data["Image18"];
            this.image19 = _data["Image19"];
            this.image20 = _data["Image20"];
            this.hourOpenDefault = _data["HourOpenDefault"];
            this.minutesOpenDefault = _data["MinutesOpenDefault"];
            this.hourCloseDefault = _data["HourCloseDefault"];
            this.minutesCloseDefault = _data["MinutesCloseDefault"];
            this.isHotDeal = _data["IsHotDeal"];
            this.priceUnit = _data["PriceUnit"];
        }
    }

    static fromJS(data: any): PhotographerPost {
        data = typeof data === 'object' ? data : {};
        let result = new PhotographerPost();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantId"] = this.tenantId;
        data["Name"] = this.name;
        data["Address"] = this.address;
        data["Price"] = this.price;
        data["Sales"] = this.sales;
        data["BookingCount"] = this.bookingCount;
        data["Description"] = this.description;
        data["Image1"] = this.image1;
        data["Image2"] = this.image2;
        data["Image3"] = this.image3;
        data["Image4"] = this.image4;
        data["Image5"] = this.image5;
        data["Image6"] = this.image6;
        data["Image7"] = this.image7;
        data["Image8"] = this.image8;
        data["Image9"] = this.image9;
        data["Image10"] = this.image10;
        data["Image11"] = this.image11;
        data["Image12"] = this.image12;
        data["Image13"] = this.image13;
        data["Image14"] = this.image14;
        data["Image15"] = this.image15;
        data["Image16"] = this.image16;
        data["Image17"] = this.image17;
        data["Image18"] = this.image18;
        data["Image19"] = this.image19;
        data["Image20"] = this.image20;
        data["HourOpenDefault"] = this.hourOpenDefault;
        data["MinutesOpenDefault"] = this.minutesOpenDefault;
        data["HourCloseDefault"] = this.hourCloseDefault;
        data["MinutesCloseDefault"] = this.minutesCloseDefault;
        data["IsHotDeal"] = this.isHotDeal;
        data["PriceUnit"] = this.priceUnit;
        super.toJSON(data);
        return data;
    }
}

export interface IPhotographerPost extends IFullAuditedEntity {
    tenantId?: number | undefined;
    name: string;
    address?: string | undefined;
    price?: number;
    sales?: number;
    bookingCount?: number;
    description?: string | undefined;
    image1?: string | undefined;
    image2?: string | undefined;
    image3?: string | undefined;
    image4?: string | undefined;
    image5?: string | undefined;
    image6?: string | undefined;
    image7?: string | undefined;
    image8?: string | undefined;
    image9?: string | undefined;
    image10?: string | undefined;
    image11?: string | undefined;
    image12?: string | undefined;
    image13?: string | undefined;
    image14?: string | undefined;
    image15?: string | undefined;
    image16?: string | undefined;
    image17?: string | undefined;
    image18?: string | undefined;
    image19?: string | undefined;
    image20?: string | undefined;
    hourOpenDefault?: number;
    minutesOpenDefault?: number;
    hourCloseDefault?: number;
    minutesCloseDefault?: number;
    isHotDeal?: boolean;
    priceUnit?: string | undefined;
}

export class PhotographerServicePackage extends FullAuditedEntity implements IPhotographerServicePackage {
    tenantId?: number | undefined;
    name!: string;
    price?: number;
    sales?: number;
    priceNote?: string | undefined;
    image1?: string | undefined;
    image2?: string | undefined;
    image3?: string | undefined;
    image4?: string | undefined;
    image5?: string | undefined;
    image6?: string | undefined;
    image7?: string | undefined;
    image8?: string | undefined;
    image9?: string | undefined;
    image10?: string | undefined;
    image11?: string | undefined;
    image12?: string | undefined;
    image13?: string | undefined;
    image14?: string | undefined;
    image15?: string | undefined;
    image16?: string | undefined;
    image17?: string | undefined;
    image18?: string | undefined;
    image19?: string | undefined;
    image20?: string | undefined;
    description?: string | undefined;
    photographerPostId?: number | undefined;
    photographerPostFk?: PhotographerPost | undefined;

    constructor(data?: IPhotographerServicePackage) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tenantId = _data["TenantId"];
            this.name = _data["Name"];
            this.price = _data["Price"];
            this.sales = _data["Sales"];
            this.priceNote = _data["PriceNote"];
            this.image1 = _data["Image1"];
            this.image2 = _data["Image2"];
            this.image3 = _data["Image3"];
            this.image4 = _data["Image4"];
            this.image5 = _data["Image5"];
            this.image6 = _data["Image6"];
            this.image7 = _data["Image7"];
            this.image8 = _data["Image8"];
            this.image9 = _data["Image9"];
            this.image10 = _data["Image10"];
            this.image11 = _data["Image11"];
            this.image12 = _data["Image12"];
            this.image13 = _data["Image13"];
            this.image14 = _data["Image14"];
            this.image15 = _data["Image15"];
            this.image16 = _data["Image16"];
            this.image17 = _data["Image17"];
            this.image18 = _data["Image18"];
            this.image19 = _data["Image19"];
            this.image20 = _data["Image20"];
            this.description = _data["Description"];
            this.photographerPostId = _data["PhotographerPostId"];
            this.photographerPostFk = _data["PhotographerPostFk"] ? PhotographerPost.fromJS(_data["PhotographerPostFk"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PhotographerServicePackage {
        data = typeof data === 'object' ? data : {};
        let result = new PhotographerServicePackage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantId"] = this.tenantId;
        data["Name"] = this.name;
        data["Price"] = this.price;
        data["Sales"] = this.sales;
        data["PriceNote"] = this.priceNote;
        data["Image1"] = this.image1;
        data["Image2"] = this.image2;
        data["Image3"] = this.image3;
        data["Image4"] = this.image4;
        data["Image5"] = this.image5;
        data["Image6"] = this.image6;
        data["Image7"] = this.image7;
        data["Image8"] = this.image8;
        data["Image9"] = this.image9;
        data["Image10"] = this.image10;
        data["Image11"] = this.image11;
        data["Image12"] = this.image12;
        data["Image13"] = this.image13;
        data["Image14"] = this.image14;
        data["Image15"] = this.image15;
        data["Image16"] = this.image16;
        data["Image17"] = this.image17;
        data["Image18"] = this.image18;
        data["Image19"] = this.image19;
        data["Image20"] = this.image20;
        data["Description"] = this.description;
        data["PhotographerPostId"] = this.photographerPostId;
        data["PhotographerPostFk"] = this.photographerPostFk ? this.photographerPostFk.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPhotographerServicePackage extends IFullAuditedEntity {
    tenantId?: number | undefined;
    name: string;
    price?: number;
    sales?: number;
    priceNote?: string | undefined;
    image1?: string | undefined;
    image2?: string | undefined;
    image3?: string | undefined;
    image4?: string | undefined;
    image5?: string | undefined;
    image6?: string | undefined;
    image7?: string | undefined;
    image8?: string | undefined;
    image9?: string | undefined;
    image10?: string | undefined;
    image11?: string | undefined;
    image12?: string | undefined;
    image13?: string | undefined;
    image14?: string | undefined;
    image15?: string | undefined;
    image16?: string | undefined;
    image17?: string | undefined;
    image18?: string | undefined;
    image19?: string | undefined;
    image20?: string | undefined;
    description?: string | undefined;
    photographerPostId?: number | undefined;
    photographerPostFk?: PhotographerPost | undefined;
}

export class PGPromoCode extends FullAuditedEntity implements IPGPromoCode {
    tenantId?: number | undefined;
    code!: string;
    description?: string | undefined;
    expired?: Date;
    name?: string | undefined;
    discountAmount?: number;
    photographerPostId?: number | undefined;
    photographerPostFk?: PhotographerPost | undefined;
    photographerServicePackageId?: number | undefined;
    photographerServicePackageFk?: PhotographerServicePackage | undefined;

    constructor(data?: IPGPromoCode) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tenantId = _data["TenantId"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.expired = _data["Expired"] ? new Date(_data["Expired"].toString()) : <any>undefined;
            this.name = _data["Name"];
            this.discountAmount = _data["DiscountAmount"];
            this.photographerPostId = _data["PhotographerPostId"];
            this.photographerPostFk = _data["PhotographerPostFk"] ? PhotographerPost.fromJS(_data["PhotographerPostFk"]) : <any>undefined;
            this.photographerServicePackageId = _data["PhotographerServicePackageId"];
            this.photographerServicePackageFk = _data["PhotographerServicePackageFk"] ? PhotographerServicePackage.fromJS(_data["PhotographerServicePackageFk"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PGPromoCode {
        data = typeof data === 'object' ? data : {};
        let result = new PGPromoCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantId"] = this.tenantId;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["Expired"] = this.expired ? this.expired.toISOString() : <any>undefined;
        data["Name"] = this.name;
        data["DiscountAmount"] = this.discountAmount;
        data["PhotographerPostId"] = this.photographerPostId;
        data["PhotographerPostFk"] = this.photographerPostFk ? this.photographerPostFk.toJSON() : <any>undefined;
        data["PhotographerServicePackageId"] = this.photographerServicePackageId;
        data["PhotographerServicePackageFk"] = this.photographerServicePackageFk ? this.photographerServicePackageFk.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPGPromoCode extends IFullAuditedEntity {
    tenantId?: number | undefined;
    code: string;
    description?: string | undefined;
    expired?: Date;
    name?: string | undefined;
    discountAmount?: number;
    photographerPostId?: number | undefined;
    photographerPostFk?: PhotographerPost | undefined;
    photographerServicePackageId?: number | undefined;
    photographerServicePackageFk?: PhotographerServicePackage | undefined;
}

export class Photographerorder implements IPhotographerorder {
    photographerName?: string | undefined;
    servicePackName?: string | undefined;
    photographerProvinceName?: string | undefined;
    photographerAvatar?: string | undefined;
    paymentTypeName?: string | undefined;
    price?: number;
    sales?: number;
    pricetype?: number;
    photographerUserId?: number;
    id?: number;
    servicepackid?: number;
    servicepackpriceid?: number;
    userid?: number;
    phone?: string | undefined;
    fullname?: string | undefined;
    fromdate?: Date | undefined;
    todate?: Date | undefined;
    createddate?: Date | undefined;
    updateddate?: Date | undefined;
    status?: number | undefined;
    cancelreasonid?: number | undefined;
    otherreason?: string | undefined;

    constructor(data?: IPhotographerorder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.photographerName = _data["PhotographerName"];
            this.servicePackName = _data["ServicePackName"];
            this.photographerProvinceName = _data["PhotographerProvinceName"];
            this.photographerAvatar = _data["PhotographerAvatar"];
            this.paymentTypeName = _data["PaymentTypeName"];
            this.price = _data["Price"];
            this.sales = _data["Sales"];
            this.pricetype = _data["Pricetype"];
            this.photographerUserId = _data["PhotographerUserId"];
            this.id = _data["Id"];
            this.servicepackid = _data["Servicepackid"];
            this.servicepackpriceid = _data["Servicepackpriceid"];
            this.userid = _data["Userid"];
            this.phone = _data["Phone"];
            this.fullname = _data["Fullname"];
            this.fromdate = _data["Fromdate"] ? new Date(_data["Fromdate"].toString()) : <any>undefined;
            this.todate = _data["Todate"] ? new Date(_data["Todate"].toString()) : <any>undefined;
            this.createddate = _data["Createddate"] ? new Date(_data["Createddate"].toString()) : <any>undefined;
            this.updateddate = _data["Updateddate"] ? new Date(_data["Updateddate"].toString()) : <any>undefined;
            this.status = _data["Status"];
            this.cancelreasonid = _data["Cancelreasonid"];
            this.otherreason = _data["Otherreason"];
        }
    }

    static fromJS(data: any): Photographerorder {
        data = typeof data === 'object' ? data : {};
        let result = new Photographerorder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PhotographerName"] = this.photographerName;
        data["ServicePackName"] = this.servicePackName;
        data["PhotographerProvinceName"] = this.photographerProvinceName;
        data["PhotographerAvatar"] = this.photographerAvatar;
        data["PaymentTypeName"] = this.paymentTypeName;
        data["Price"] = this.price;
        data["Sales"] = this.sales;
        data["Pricetype"] = this.pricetype;
        data["PhotographerUserId"] = this.photographerUserId;
        data["Id"] = this.id;
        data["Servicepackid"] = this.servicepackid;
        data["Servicepackpriceid"] = this.servicepackpriceid;
        data["Userid"] = this.userid;
        data["Phone"] = this.phone;
        data["Fullname"] = this.fullname;
        data["Fromdate"] = this.fromdate ? this.fromdate.toISOString() : <any>undefined;
        data["Todate"] = this.todate ? this.todate.toISOString() : <any>undefined;
        data["Createddate"] = this.createddate ? this.createddate.toISOString() : <any>undefined;
        data["Updateddate"] = this.updateddate ? this.updateddate.toISOString() : <any>undefined;
        data["Status"] = this.status;
        data["Cancelreasonid"] = this.cancelreasonid;
        data["Otherreason"] = this.otherreason;
        return data;
    }
}

export interface IPhotographerorder {
    photographerName?: string | undefined;
    servicePackName?: string | undefined;
    photographerProvinceName?: string | undefined;
    photographerAvatar?: string | undefined;
    paymentTypeName?: string | undefined;
    price?: number;
    sales?: number;
    pricetype?: number;
    photographerUserId?: number;
    id?: number;
    servicepackid?: number;
    servicepackpriceid?: number;
    userid?: number;
    phone?: string | undefined;
    fullname?: string | undefined;
    fromdate?: Date | undefined;
    todate?: Date | undefined;
    createddate?: Date | undefined;
    updateddate?: Date | undefined;
    status?: number | undefined;
    cancelreasonid?: number | undefined;
    otherreason?: string | undefined;
}

export class Pricetype implements IPricetype {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IPricetype) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
        }
    }

    static fromJS(data: any): Pricetype {
        data = typeof data === 'object' ? data : {};
        let result = new Pricetype();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        return data;
    }
}

export interface IPricetype {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class User implements IUser {
    id?: number;
    usertype?: number;
    email?: string | undefined;
    username?: string | undefined;
    phone?: string | undefined;
    hashpassword?: string | undefined;
    salt?: string | undefined;
    fullname?: string | undefined;
    createddate?: Date | undefined;
    updateddate?: Date | undefined;
    status?: number | undefined;
    updatedby?: number | undefined;
    imageurl?: string | undefined;
    facebookid?: string | undefined;
    googleemail?: string | undefined;
    facebooktoken?: string | undefined;
    facebookfirstname?: string | undefined;
    facebooklastname?: string | undefined;
    facebookemail?: string | undefined;
    facebookpicture?: string | undefined;
    googlename?: string | undefined;
    googlepicture?: string | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.usertype = _data["Usertype"];
            this.email = _data["Email"];
            this.username = _data["Username"];
            this.phone = _data["Phone"];
            this.hashpassword = _data["Hashpassword"];
            this.salt = _data["Salt"];
            this.fullname = _data["Fullname"];
            this.createddate = _data["Createddate"] ? new Date(_data["Createddate"].toString()) : <any>undefined;
            this.updateddate = _data["Updateddate"] ? new Date(_data["Updateddate"].toString()) : <any>undefined;
            this.status = _data["Status"];
            this.updatedby = _data["Updatedby"];
            this.imageurl = _data["Imageurl"];
            this.facebookid = _data["Facebookid"];
            this.googleemail = _data["Googleemail"];
            this.facebooktoken = _data["Facebooktoken"];
            this.facebookfirstname = _data["Facebookfirstname"];
            this.facebooklastname = _data["Facebooklastname"];
            this.facebookemail = _data["Facebookemail"];
            this.facebookpicture = _data["Facebookpicture"];
            this.googlename = _data["Googlename"];
            this.googlepicture = _data["Googlepicture"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Usertype"] = this.usertype;
        data["Email"] = this.email;
        data["Username"] = this.username;
        data["Phone"] = this.phone;
        data["Hashpassword"] = this.hashpassword;
        data["Salt"] = this.salt;
        data["Fullname"] = this.fullname;
        data["Createddate"] = this.createddate ? this.createddate.toISOString() : <any>undefined;
        data["Updateddate"] = this.updateddate ? this.updateddate.toISOString() : <any>undefined;
        data["Status"] = this.status;
        data["Updatedby"] = this.updatedby;
        data["Imageurl"] = this.imageurl;
        data["Facebookid"] = this.facebookid;
        data["Googleemail"] = this.googleemail;
        data["Facebooktoken"] = this.facebooktoken;
        data["Facebookfirstname"] = this.facebookfirstname;
        data["Facebooklastname"] = this.facebooklastname;
        data["Facebookemail"] = this.facebookemail;
        data["Facebookpicture"] = this.facebookpicture;
        data["Googlename"] = this.googlename;
        data["Googlepicture"] = this.googlepicture;
        return data;
    }
}

export interface IUser {
    id?: number;
    usertype?: number;
    email?: string | undefined;
    username?: string | undefined;
    phone?: string | undefined;
    hashpassword?: string | undefined;
    salt?: string | undefined;
    fullname?: string | undefined;
    createddate?: Date | undefined;
    updateddate?: Date | undefined;
    status?: number | undefined;
    updatedby?: number | undefined;
    imageurl?: string | undefined;
    facebookid?: string | undefined;
    googleemail?: string | undefined;
    facebooktoken?: string | undefined;
    facebookfirstname?: string | undefined;
    facebooklastname?: string | undefined;
    facebookemail?: string | undefined;
    facebookpicture?: string | undefined;
    googlename?: string | undefined;
    googlepicture?: string | undefined;
}

export class ResourceDataResponse implements IResourceDataResponse {
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: IResourceDataResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["Key"];
            this.value = _data["Value"];
        }
    }

    static fromJS(data: any): ResourceDataResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceDataResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Key"] = this.key;
        data["Value"] = this.value;
        return data;
    }
}

export interface IResourceDataResponse {
    key?: string | undefined;
    value?: string | undefined;
}

export class SearchRequest implements ISearchRequest {
    priceFrom?: number;
    priceTo?: number;
    provinceId?: number;
    districtIds?: number[] | undefined;
    categories?: string[] | undefined;
    priceType?: string | undefined;
    isOrderByRateCount?: boolean;
    isOrderByTopRate?: boolean;
    isOrderByBookingCount?: boolean;

    constructor(data?: ISearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.priceFrom = _data["PriceFrom"];
            this.priceTo = _data["PriceTo"];
            this.provinceId = _data["ProvinceId"];
            if (Array.isArray(_data["DistrictIds"])) {
                this.districtIds = [] as any;
                for (let item of _data["DistrictIds"])
                    this.districtIds!.push(item);
            }
            if (Array.isArray(_data["Categories"])) {
                this.categories = [] as any;
                for (let item of _data["Categories"])
                    this.categories!.push(item);
            }
            this.priceType = _data["PriceType"];
            this.isOrderByRateCount = _data["IsOrderByRateCount"];
            this.isOrderByTopRate = _data["IsOrderByTopRate"];
            this.isOrderByBookingCount = _data["IsOrderByBookingCount"];
        }
    }

    static fromJS(data: any): SearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PriceFrom"] = this.priceFrom;
        data["PriceTo"] = this.priceTo;
        data["ProvinceId"] = this.provinceId;
        if (Array.isArray(this.districtIds)) {
            data["DistrictIds"] = [];
            for (let item of this.districtIds)
                data["DistrictIds"].push(item);
        }
        if (Array.isArray(this.categories)) {
            data["Categories"] = [];
            for (let item of this.categories)
                data["Categories"].push(item);
        }
        data["PriceType"] = this.priceType;
        data["IsOrderByRateCount"] = this.isOrderByRateCount;
        data["IsOrderByTopRate"] = this.isOrderByTopRate;
        data["IsOrderByBookingCount"] = this.isOrderByBookingCount;
        return data;
    }
}

export interface ISearchRequest {
    priceFrom?: number;
    priceTo?: number;
    provinceId?: number;
    districtIds?: number[] | undefined;
    categories?: string[] | undefined;
    priceType?: string | undefined;
    isOrderByRateCount?: boolean;
    isOrderByTopRate?: boolean;
    isOrderByBookingCount?: boolean;
}

export class Servicepack implements IServicepack {
    fileImages?: Uploadfile[] | undefined;
    fileVideos?: Uploadfile[] | undefined;
    servicePackPrices?: Servicepackprice[] | undefined;
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    imagegroupid?: number | undefined;
    videogroupid?: number | undefined;
    owner?: number | undefined;
    isedited?: number | undefined;
    createddate?: Date | undefined;
    updateddate?: Date | undefined;

    constructor(data?: IServicepack) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["FileImages"])) {
                this.fileImages = [] as any;
                for (let item of _data["FileImages"])
                    this.fileImages!.push(Uploadfile.fromJS(item));
            }
            if (Array.isArray(_data["FileVideos"])) {
                this.fileVideos = [] as any;
                for (let item of _data["FileVideos"])
                    this.fileVideos!.push(Uploadfile.fromJS(item));
            }
            if (Array.isArray(_data["ServicePackPrices"])) {
                this.servicePackPrices = [] as any;
                for (let item of _data["ServicePackPrices"])
                    this.servicePackPrices!.push(Servicepackprice.fromJS(item));
            }
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.imagegroupid = _data["Imagegroupid"];
            this.videogroupid = _data["Videogroupid"];
            this.owner = _data["Owner"];
            this.isedited = _data["Isedited"];
            this.createddate = _data["Createddate"] ? new Date(_data["Createddate"].toString()) : <any>undefined;
            this.updateddate = _data["Updateddate"] ? new Date(_data["Updateddate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Servicepack {
        data = typeof data === 'object' ? data : {};
        let result = new Servicepack();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fileImages)) {
            data["FileImages"] = [];
            for (let item of this.fileImages)
                data["FileImages"].push(item.toJSON());
        }
        if (Array.isArray(this.fileVideos)) {
            data["FileVideos"] = [];
            for (let item of this.fileVideos)
                data["FileVideos"].push(item.toJSON());
        }
        if (Array.isArray(this.servicePackPrices)) {
            data["ServicePackPrices"] = [];
            for (let item of this.servicePackPrices)
                data["ServicePackPrices"].push(item.toJSON());
        }
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["Imagegroupid"] = this.imagegroupid;
        data["Videogroupid"] = this.videogroupid;
        data["Owner"] = this.owner;
        data["Isedited"] = this.isedited;
        data["Createddate"] = this.createddate ? this.createddate.toISOString() : <any>undefined;
        data["Updateddate"] = this.updateddate ? this.updateddate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IServicepack {
    fileImages?: Uploadfile[] | undefined;
    fileVideos?: Uploadfile[] | undefined;
    servicePackPrices?: Servicepackprice[] | undefined;
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    imagegroupid?: number | undefined;
    videogroupid?: number | undefined;
    owner?: number | undefined;
    isedited?: number | undefined;
    createddate?: Date | undefined;
    updateddate?: Date | undefined;
}

export class Servicepackprice implements IServicepackprice {
    id?: number;
    servicepackid?: number;
    days?: string | undefined;
    price?: number;
    ismin?: number | undefined;
    sales?: number;
    pricetype?: number;
    servicepaymenttype?: number;
    createddate?: Date | undefined;
    updateddate?: Date | undefined;

    constructor(data?: IServicepackprice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.servicepackid = _data["Servicepackid"];
            this.days = _data["Days"];
            this.price = _data["Price"];
            this.ismin = _data["Ismin"];
            this.sales = _data["Sales"];
            this.pricetype = _data["Pricetype"];
            this.servicepaymenttype = _data["Servicepaymenttype"];
            this.createddate = _data["Createddate"] ? new Date(_data["Createddate"].toString()) : <any>undefined;
            this.updateddate = _data["Updateddate"] ? new Date(_data["Updateddate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Servicepackprice {
        data = typeof data === 'object' ? data : {};
        let result = new Servicepackprice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Servicepackid"] = this.servicepackid;
        data["Days"] = this.days;
        data["Price"] = this.price;
        data["Ismin"] = this.ismin;
        data["Sales"] = this.sales;
        data["Pricetype"] = this.pricetype;
        data["Servicepaymenttype"] = this.servicepaymenttype;
        data["Createddate"] = this.createddate ? this.createddate.toISOString() : <any>undefined;
        data["Updateddate"] = this.updateddate ? this.updateddate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IServicepackprice {
    id?: number;
    servicepackid?: number;
    days?: string | undefined;
    price?: number;
    ismin?: number | undefined;
    sales?: number;
    pricetype?: number;
    servicepaymenttype?: number;
    createddate?: Date | undefined;
    updateddate?: Date | undefined;
}

export class Servicepaymenttype implements IServicepaymenttype {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IServicepaymenttype) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
        }
    }

    static fromJS(data: any): Servicepaymenttype {
        data = typeof data === 'object' ? data : {};
        let result = new Servicepaymenttype();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        return data;
    }
}

export interface IServicepaymenttype {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class Specialday implements ISpecialday {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: ISpecialday) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
        }
    }

    static fromJS(data: any): Specialday {
        data = typeof data === 'object' ? data : {};
        let result = new Specialday();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        return data;
    }
}

export interface ISpecialday {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class StudioPost extends FullAuditedEntity implements IStudioPost {
    tenantId?: number | undefined;
    name!: string;
    address!: string;
    latitude?: number;
    longtitude?: number;
    price?: number;
    sales?: number;
    priceUnit?: string | undefined;
    bookingCount?: number;
    description?: string | undefined;
    image1?: string | undefined;
    image2?: string | undefined;
    image3?: string | undefined;
    image4?: string | undefined;
    image5?: string | undefined;
    image6?: string | undefined;
    image7?: string | undefined;
    image8?: string | undefined;
    image9?: string | undefined;
    image10?: string | undefined;
    image11?: string | undefined;
    image12?: string | undefined;
    image13?: string | undefined;
    image14?: string | undefined;
    image15?: string | undefined;
    image16?: string | undefined;
    image17?: string | undefined;
    image18?: string | undefined;
    image19?: string | undefined;
    image20?: string | undefined;
    hourOpenDefault?: number;
    minutesOpenDefault?: number;
    hourCloseDefault?: number;
    minutesCloseDefault?: number;
    isHotDeal?: boolean;

    constructor(data?: IStudioPost) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tenantId = _data["TenantId"];
            this.name = _data["Name"];
            this.address = _data["Address"];
            this.latitude = _data["Latitude"];
            this.longtitude = _data["Longtitude"];
            this.price = _data["Price"];
            this.sales = _data["Sales"];
            this.priceUnit = _data["PriceUnit"];
            this.bookingCount = _data["BookingCount"];
            this.description = _data["Description"];
            this.image1 = _data["Image1"];
            this.image2 = _data["Image2"];
            this.image3 = _data["Image3"];
            this.image4 = _data["Image4"];
            this.image5 = _data["Image5"];
            this.image6 = _data["Image6"];
            this.image7 = _data["Image7"];
            this.image8 = _data["Image8"];
            this.image9 = _data["Image9"];
            this.image10 = _data["Image10"];
            this.image11 = _data["Image11"];
            this.image12 = _data["Image12"];
            this.image13 = _data["Image13"];
            this.image14 = _data["Image14"];
            this.image15 = _data["Image15"];
            this.image16 = _data["Image16"];
            this.image17 = _data["Image17"];
            this.image18 = _data["Image18"];
            this.image19 = _data["Image19"];
            this.image20 = _data["Image20"];
            this.hourOpenDefault = _data["HourOpenDefault"];
            this.minutesOpenDefault = _data["MinutesOpenDefault"];
            this.hourCloseDefault = _data["HourCloseDefault"];
            this.minutesCloseDefault = _data["MinutesCloseDefault"];
            this.isHotDeal = _data["IsHotDeal"];
        }
    }

    static fromJS(data: any): StudioPost {
        data = typeof data === 'object' ? data : {};
        let result = new StudioPost();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantId"] = this.tenantId;
        data["Name"] = this.name;
        data["Address"] = this.address;
        data["Latitude"] = this.latitude;
        data["Longtitude"] = this.longtitude;
        data["Price"] = this.price;
        data["Sales"] = this.sales;
        data["PriceUnit"] = this.priceUnit;
        data["BookingCount"] = this.bookingCount;
        data["Description"] = this.description;
        data["Image1"] = this.image1;
        data["Image2"] = this.image2;
        data["Image3"] = this.image3;
        data["Image4"] = this.image4;
        data["Image5"] = this.image5;
        data["Image6"] = this.image6;
        data["Image7"] = this.image7;
        data["Image8"] = this.image8;
        data["Image9"] = this.image9;
        data["Image10"] = this.image10;
        data["Image11"] = this.image11;
        data["Image12"] = this.image12;
        data["Image13"] = this.image13;
        data["Image14"] = this.image14;
        data["Image15"] = this.image15;
        data["Image16"] = this.image16;
        data["Image17"] = this.image17;
        data["Image18"] = this.image18;
        data["Image19"] = this.image19;
        data["Image20"] = this.image20;
        data["HourOpenDefault"] = this.hourOpenDefault;
        data["MinutesOpenDefault"] = this.minutesOpenDefault;
        data["HourCloseDefault"] = this.hourCloseDefault;
        data["MinutesCloseDefault"] = this.minutesCloseDefault;
        data["IsHotDeal"] = this.isHotDeal;
        super.toJSON(data);
        return data;
    }
}

export interface IStudioPost extends IFullAuditedEntity {
    tenantId?: number | undefined;
    name: string;
    address: string;
    latitude?: number;
    longtitude?: number;
    price?: number;
    sales?: number;
    priceUnit?: string | undefined;
    bookingCount?: number;
    description?: string | undefined;
    image1?: string | undefined;
    image2?: string | undefined;
    image3?: string | undefined;
    image4?: string | undefined;
    image5?: string | undefined;
    image6?: string | undefined;
    image7?: string | undefined;
    image8?: string | undefined;
    image9?: string | undefined;
    image10?: string | undefined;
    image11?: string | undefined;
    image12?: string | undefined;
    image13?: string | undefined;
    image14?: string | undefined;
    image15?: string | undefined;
    image16?: string | undefined;
    image17?: string | undefined;
    image18?: string | undefined;
    image19?: string | undefined;
    image20?: string | undefined;
    hourOpenDefault?: number;
    minutesOpenDefault?: number;
    hourCloseDefault?: number;
    minutesCloseDefault?: number;
    isHotDeal?: boolean;
}

export class StudioRoom extends FullAuditedEntity implements IStudioRoom {
    tenantId?: number | undefined;
    name!: string;
    area!: string;
    style?: string | undefined;
    description?: string | undefined;
    price?: number;
    sales?: number;
    priceNote?: string | undefined;
    image1?: string | undefined;
    image2?: string | undefined;
    image3?: string | undefined;
    image4?: string | undefined;
    image5?: string | undefined;
    image6?: string | undefined;
    image7?: string | undefined;
    image8?: string | undefined;
    image9?: string | undefined;
    image10?: string | undefined;
    image11?: string | undefined;
    image12?: string | undefined;
    image13?: string | undefined;
    image14?: string | undefined;
    image15?: string | undefined;
    image16?: string | undefined;
    image17?: string | undefined;
    image18?: string | undefined;
    image19?: string | undefined;
    image20?: string | undefined;
    studioPostId?: number | undefined;
    studioPostFk?: StudioPost | undefined;

    constructor(data?: IStudioRoom) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tenantId = _data["TenantId"];
            this.name = _data["Name"];
            this.area = _data["Area"];
            this.style = _data["Style"];
            this.description = _data["Description"];
            this.price = _data["Price"];
            this.sales = _data["Sales"];
            this.priceNote = _data["PriceNote"];
            this.image1 = _data["Image1"];
            this.image2 = _data["Image2"];
            this.image3 = _data["Image3"];
            this.image4 = _data["Image4"];
            this.image5 = _data["Image5"];
            this.image6 = _data["Image6"];
            this.image7 = _data["Image7"];
            this.image8 = _data["Image8"];
            this.image9 = _data["Image9"];
            this.image10 = _data["Image10"];
            this.image11 = _data["Image11"];
            this.image12 = _data["Image12"];
            this.image13 = _data["Image13"];
            this.image14 = _data["Image14"];
            this.image15 = _data["Image15"];
            this.image16 = _data["Image16"];
            this.image17 = _data["Image17"];
            this.image18 = _data["Image18"];
            this.image19 = _data["Image19"];
            this.image20 = _data["Image20"];
            this.studioPostId = _data["StudioPostId"];
            this.studioPostFk = _data["StudioPostFk"] ? StudioPost.fromJS(_data["StudioPostFk"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StudioRoom {
        data = typeof data === 'object' ? data : {};
        let result = new StudioRoom();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantId"] = this.tenantId;
        data["Name"] = this.name;
        data["Area"] = this.area;
        data["Style"] = this.style;
        data["Description"] = this.description;
        data["Price"] = this.price;
        data["Sales"] = this.sales;
        data["PriceNote"] = this.priceNote;
        data["Image1"] = this.image1;
        data["Image2"] = this.image2;
        data["Image3"] = this.image3;
        data["Image4"] = this.image4;
        data["Image5"] = this.image5;
        data["Image6"] = this.image6;
        data["Image7"] = this.image7;
        data["Image8"] = this.image8;
        data["Image9"] = this.image9;
        data["Image10"] = this.image10;
        data["Image11"] = this.image11;
        data["Image12"] = this.image12;
        data["Image13"] = this.image13;
        data["Image14"] = this.image14;
        data["Image15"] = this.image15;
        data["Image16"] = this.image16;
        data["Image17"] = this.image17;
        data["Image18"] = this.image18;
        data["Image19"] = this.image19;
        data["Image20"] = this.image20;
        data["StudioPostId"] = this.studioPostId;
        data["StudioPostFk"] = this.studioPostFk ? this.studioPostFk.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IStudioRoom extends IFullAuditedEntity {
    tenantId?: number | undefined;
    name: string;
    area: string;
    style?: string | undefined;
    description?: string | undefined;
    price?: number;
    sales?: number;
    priceNote?: string | undefined;
    image1?: string | undefined;
    image2?: string | undefined;
    image3?: string | undefined;
    image4?: string | undefined;
    image5?: string | undefined;
    image6?: string | undefined;
    image7?: string | undefined;
    image8?: string | undefined;
    image9?: string | undefined;
    image10?: string | undefined;
    image11?: string | undefined;
    image12?: string | undefined;
    image13?: string | undefined;
    image14?: string | undefined;
    image15?: string | undefined;
    image16?: string | undefined;
    image17?: string | undefined;
    image18?: string | undefined;
    image19?: string | undefined;
    image20?: string | undefined;
    studioPostId?: number | undefined;
    studioPostFk?: StudioPost | undefined;
}

export class PromoCode extends FullAuditedEntity implements IPromoCode {
    tenantId?: number | undefined;
    code!: string;
    description?: string | undefined;
    expired?: Date;
    name?: string | undefined;
    discountAmount?: number;
    studioPostId?: number | undefined;
    studioPostFk?: StudioPost | undefined;
    studioRoomId?: number | undefined;
    studioRoomFk?: StudioRoom | undefined;

    constructor(data?: IPromoCode) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tenantId = _data["TenantId"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.expired = _data["Expired"] ? new Date(_data["Expired"].toString()) : <any>undefined;
            this.name = _data["Name"];
            this.discountAmount = _data["DiscountAmount"];
            this.studioPostId = _data["StudioPostId"];
            this.studioPostFk = _data["StudioPostFk"] ? StudioPost.fromJS(_data["StudioPostFk"]) : <any>undefined;
            this.studioRoomId = _data["StudioRoomId"];
            this.studioRoomFk = _data["StudioRoomFk"] ? StudioRoom.fromJS(_data["StudioRoomFk"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PromoCode {
        data = typeof data === 'object' ? data : {};
        let result = new PromoCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantId"] = this.tenantId;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["Expired"] = this.expired ? this.expired.toISOString() : <any>undefined;
        data["Name"] = this.name;
        data["DiscountAmount"] = this.discountAmount;
        data["StudioPostId"] = this.studioPostId;
        data["StudioPostFk"] = this.studioPostFk ? this.studioPostFk.toJSON() : <any>undefined;
        data["StudioRoomId"] = this.studioRoomId;
        data["StudioRoomFk"] = this.studioRoomFk ? this.studioRoomFk.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPromoCode extends IFullAuditedEntity {
    tenantId?: number | undefined;
    code: string;
    description?: string | undefined;
    expired?: Date;
    name?: string | undefined;
    discountAmount?: number;
    studioPostId?: number | undefined;
    studioPostFk?: StudioPost | undefined;
    studioRoomId?: number | undefined;
    studioRoomFk?: StudioRoom | undefined;
}

export class StudioBooking extends FullAuditedEntity implements IStudioBooking {
    tenantId?: number | undefined;
    orderByTime?: boolean;
    orderByTimeFrom?: Date;
    orderByTimeTo?: Date;
    orderByDateFrom?: Date;
    orderByDateTo?: Date;
    paymentType?: string | undefined;
    orderNote?: string | undefined;
    bookingUserName?: string | undefined;
    bookingPhone?: string | undefined;
    bookingEmail?: string | undefined;
    evidenceImage?: string | undefined;
    isPayDeposit?: boolean;
    studioRoomId?: number | undefined;
    studioRoomFk?: StudioRoom | undefined;
    bookingUserId?: number | undefined;
    bookingUserFk?: BookingUser | undefined;
    promoCodeId?: number | undefined;
    promoCodeFk?: PromoCode | undefined;

    constructor(data?: IStudioBooking) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tenantId = _data["TenantId"];
            this.orderByTime = _data["OrderByTime"];
            this.orderByTimeFrom = _data["OrderByTimeFrom"] ? new Date(_data["OrderByTimeFrom"].toString()) : <any>undefined;
            this.orderByTimeTo = _data["OrderByTimeTo"] ? new Date(_data["OrderByTimeTo"].toString()) : <any>undefined;
            this.orderByDateFrom = _data["OrderByDateFrom"] ? new Date(_data["OrderByDateFrom"].toString()) : <any>undefined;
            this.orderByDateTo = _data["OrderByDateTo"] ? new Date(_data["OrderByDateTo"].toString()) : <any>undefined;
            this.paymentType = _data["PaymentType"];
            this.orderNote = _data["OrderNote"];
            this.bookingUserName = _data["BookingUserName"];
            this.bookingPhone = _data["BookingPhone"];
            this.bookingEmail = _data["BookingEmail"];
            this.evidenceImage = _data["EvidenceImage"];
            this.isPayDeposit = _data["IsPayDeposit"];
            this.studioRoomId = _data["StudioRoomId"];
            this.studioRoomFk = _data["StudioRoomFk"] ? StudioRoom.fromJS(_data["StudioRoomFk"]) : <any>undefined;
            this.bookingUserId = _data["BookingUserId"];
            this.bookingUserFk = _data["BookingUserFk"] ? BookingUser.fromJS(_data["BookingUserFk"]) : <any>undefined;
            this.promoCodeId = _data["PromoCodeId"];
            this.promoCodeFk = _data["PromoCodeFk"] ? PromoCode.fromJS(_data["PromoCodeFk"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StudioBooking {
        data = typeof data === 'object' ? data : {};
        let result = new StudioBooking();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantId"] = this.tenantId;
        data["OrderByTime"] = this.orderByTime;
        data["OrderByTimeFrom"] = this.orderByTimeFrom ? this.orderByTimeFrom.toISOString() : <any>undefined;
        data["OrderByTimeTo"] = this.orderByTimeTo ? this.orderByTimeTo.toISOString() : <any>undefined;
        data["OrderByDateFrom"] = this.orderByDateFrom ? this.orderByDateFrom.toISOString() : <any>undefined;
        data["OrderByDateTo"] = this.orderByDateTo ? this.orderByDateTo.toISOString() : <any>undefined;
        data["PaymentType"] = this.paymentType;
        data["OrderNote"] = this.orderNote;
        data["BookingUserName"] = this.bookingUserName;
        data["BookingPhone"] = this.bookingPhone;
        data["BookingEmail"] = this.bookingEmail;
        data["EvidenceImage"] = this.evidenceImage;
        data["IsPayDeposit"] = this.isPayDeposit;
        data["StudioRoomId"] = this.studioRoomId;
        data["StudioRoomFk"] = this.studioRoomFk ? this.studioRoomFk.toJSON() : <any>undefined;
        data["BookingUserId"] = this.bookingUserId;
        data["BookingUserFk"] = this.bookingUserFk ? this.bookingUserFk.toJSON() : <any>undefined;
        data["PromoCodeId"] = this.promoCodeId;
        data["PromoCodeFk"] = this.promoCodeFk ? this.promoCodeFk.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IStudioBooking extends IFullAuditedEntity {
    tenantId?: number | undefined;
    orderByTime?: boolean;
    orderByTimeFrom?: Date;
    orderByTimeTo?: Date;
    orderByDateFrom?: Date;
    orderByDateTo?: Date;
    paymentType?: string | undefined;
    orderNote?: string | undefined;
    bookingUserName?: string | undefined;
    bookingPhone?: string | undefined;
    bookingEmail?: string | undefined;
    evidenceImage?: string | undefined;
    isPayDeposit?: boolean;
    studioRoomId?: number | undefined;
    studioRoomFk?: StudioRoom | undefined;
    bookingUserId?: number | undefined;
    bookingUserFk?: BookingUser | undefined;
    promoCodeId?: number | undefined;
    promoCodeFk?: PromoCode | undefined;
}

export class UploadEvidenceImageRequest implements IUploadEvidenceImageRequest {
    studioBookingId?: number;
    imageBase64?: string | undefined;

    constructor(data?: IUploadEvidenceImageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studioBookingId = _data["StudioBookingId"];
            this.imageBase64 = _data["ImageBase64"];
        }
    }

    static fromJS(data: any): UploadEvidenceImageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UploadEvidenceImageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["StudioBookingId"] = this.studioBookingId;
        data["ImageBase64"] = this.imageBase64;
        return data;
    }
}

export interface IUploadEvidenceImageRequest {
    studioBookingId?: number;
    imageBase64?: string | undefined;
}

export class StudioRatingResponse implements IStudioRatingResponse {
    userRateName?: string | undefined;
    userRateAvatar?: string | undefined;
    id?: number;
    tenantId?: number | undefined;
    rate?: number;
    description?: string | undefined;
    image1?: string | undefined;
    image2?: string | undefined;
    image3?: string | undefined;
    image4?: string | undefined;
    image5?: string | undefined;
    image6?: string | undefined;
    image7?: string | undefined;
    image8?: string | undefined;
    image9?: string | undefined;
    image10?: string | undefined;
    video1?: string | undefined;
    video2?: string | undefined;
    video3?: string | undefined;
    video4?: string | undefined;
    video5?: string | undefined;
    video6?: string | undefined;
    video7?: string | undefined;
    video8?: string | undefined;
    video9?: string | undefined;
    video10?: string | undefined;
    replyComment?: string | undefined;
    isAnonymous?: boolean;
    videoThumb1?: string | undefined;
    videoThumb2?: string | undefined;
    videoThumb3?: string | undefined;
    videoThumb4?: string | undefined;
    videoThumb5?: string | undefined;
    videoThumb6?: string | undefined;
    videoThumb7?: string | undefined;
    videoThumb8?: string | undefined;
    videoThumb9?: string | undefined;
    videoThumb10?: string | undefined;
    studioReply?: string | undefined;
    bookingUserId?: number | undefined;
    studioPostId?: number | undefined;
    studioRoomId?: number | undefined;

    constructor(data?: IStudioRatingResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRateName = _data["UserRateName"];
            this.userRateAvatar = _data["UserRateAvatar"];
            this.id = _data["Id"];
            this.tenantId = _data["TenantId"];
            this.rate = _data["Rate"];
            this.description = _data["Description"];
            this.image1 = _data["Image1"];
            this.image2 = _data["Image2"];
            this.image3 = _data["Image3"];
            this.image4 = _data["Image4"];
            this.image5 = _data["Image5"];
            this.image6 = _data["Image6"];
            this.image7 = _data["Image7"];
            this.image8 = _data["Image8"];
            this.image9 = _data["Image9"];
            this.image10 = _data["Image10"];
            this.video1 = _data["Video1"];
            this.video2 = _data["Video2"];
            this.video3 = _data["Video3"];
            this.video4 = _data["Video4"];
            this.video5 = _data["Video5"];
            this.video6 = _data["Video6"];
            this.video7 = _data["Video7"];
            this.video8 = _data["Video8"];
            this.video9 = _data["Video9"];
            this.video10 = _data["Video10"];
            this.replyComment = _data["ReplyComment"];
            this.isAnonymous = _data["IsAnonymous"];
            this.videoThumb1 = _data["VideoThumb1"];
            this.videoThumb2 = _data["VideoThumb2"];
            this.videoThumb3 = _data["VideoThumb3"];
            this.videoThumb4 = _data["VideoThumb4"];
            this.videoThumb5 = _data["VideoThumb5"];
            this.videoThumb6 = _data["VideoThumb6"];
            this.videoThumb7 = _data["VideoThumb7"];
            this.videoThumb8 = _data["VideoThumb8"];
            this.videoThumb9 = _data["VideoThumb9"];
            this.videoThumb10 = _data["VideoThumb10"];
            this.studioReply = _data["StudioReply"];
            this.bookingUserId = _data["BookingUserId"];
            this.studioPostId = _data["StudioPostId"];
            this.studioRoomId = _data["StudioRoomId"];
        }
    }

    static fromJS(data: any): StudioRatingResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StudioRatingResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserRateName"] = this.userRateName;
        data["UserRateAvatar"] = this.userRateAvatar;
        data["Id"] = this.id;
        data["TenantId"] = this.tenantId;
        data["Rate"] = this.rate;
        data["Description"] = this.description;
        data["Image1"] = this.image1;
        data["Image2"] = this.image2;
        data["Image3"] = this.image3;
        data["Image4"] = this.image4;
        data["Image5"] = this.image5;
        data["Image6"] = this.image6;
        data["Image7"] = this.image7;
        data["Image8"] = this.image8;
        data["Image9"] = this.image9;
        data["Image10"] = this.image10;
        data["Video1"] = this.video1;
        data["Video2"] = this.video2;
        data["Video3"] = this.video3;
        data["Video4"] = this.video4;
        data["Video5"] = this.video5;
        data["Video6"] = this.video6;
        data["Video7"] = this.video7;
        data["Video8"] = this.video8;
        data["Video9"] = this.video9;
        data["Video10"] = this.video10;
        data["ReplyComment"] = this.replyComment;
        data["IsAnonymous"] = this.isAnonymous;
        data["VideoThumb1"] = this.videoThumb1;
        data["VideoThumb2"] = this.videoThumb2;
        data["VideoThumb3"] = this.videoThumb3;
        data["VideoThumb4"] = this.videoThumb4;
        data["VideoThumb5"] = this.videoThumb5;
        data["VideoThumb6"] = this.videoThumb6;
        data["VideoThumb7"] = this.videoThumb7;
        data["VideoThumb8"] = this.videoThumb8;
        data["VideoThumb9"] = this.videoThumb9;
        data["VideoThumb10"] = this.videoThumb10;
        data["StudioReply"] = this.studioReply;
        data["BookingUserId"] = this.bookingUserId;
        data["StudioPostId"] = this.studioPostId;
        data["StudioRoomId"] = this.studioRoomId;
        return data;
    }
}

export interface IStudioRatingResponse {
    userRateName?: string | undefined;
    userRateAvatar?: string | undefined;
    id?: number;
    tenantId?: number | undefined;
    rate?: number;
    description?: string | undefined;
    image1?: string | undefined;
    image2?: string | undefined;
    image3?: string | undefined;
    image4?: string | undefined;
    image5?: string | undefined;
    image6?: string | undefined;
    image7?: string | undefined;
    image8?: string | undefined;
    image9?: string | undefined;
    image10?: string | undefined;
    video1?: string | undefined;
    video2?: string | undefined;
    video3?: string | undefined;
    video4?: string | undefined;
    video5?: string | undefined;
    video6?: string | undefined;
    video7?: string | undefined;
    video8?: string | undefined;
    video9?: string | undefined;
    video10?: string | undefined;
    replyComment?: string | undefined;
    isAnonymous?: boolean;
    videoThumb1?: string | undefined;
    videoThumb2?: string | undefined;
    videoThumb3?: string | undefined;
    videoThumb4?: string | undefined;
    videoThumb5?: string | undefined;
    videoThumb6?: string | undefined;
    videoThumb7?: string | undefined;
    videoThumb8?: string | undefined;
    videoThumb9?: string | undefined;
    videoThumb10?: string | undefined;
    studioReply?: string | undefined;
    bookingUserId?: number | undefined;
    studioPostId?: number | undefined;
    studioRoomId?: number | undefined;
}

export class UserRegisterRequest implements IUserRegisterRequest {
    email?: string | undefined;
    username?: string | undefined;
    phone?: string | undefined;
    companyname?: string | undefined;
    fullname?: string | undefined;
    experience?: string | undefined;
    website?: string | undefined;
    password?: string | undefined;
    rePassword?: string | undefined;
    userType?: number;

    constructor(data?: IUserRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["Email"];
            this.username = _data["Username"];
            this.phone = _data["Phone"];
            this.companyname = _data["Companyname"];
            this.fullname = _data["Fullname"];
            this.experience = _data["Experience"];
            this.website = _data["Website"];
            this.password = _data["Password"];
            this.rePassword = _data["RePassword"];
            this.userType = _data["UserType"];
        }
    }

    static fromJS(data: any): UserRegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserRegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Email"] = this.email;
        data["Username"] = this.username;
        data["Phone"] = this.phone;
        data["Companyname"] = this.companyname;
        data["Fullname"] = this.fullname;
        data["Experience"] = this.experience;
        data["Website"] = this.website;
        data["Password"] = this.password;
        data["RePassword"] = this.rePassword;
        data["UserType"] = this.userType;
        return data;
    }
}

export interface IUserRegisterRequest {
    email?: string | undefined;
    username?: string | undefined;
    phone?: string | undefined;
    companyname?: string | undefined;
    fullname?: string | undefined;
    experience?: string | undefined;
    website?: string | undefined;
    password?: string | undefined;
    rePassword?: string | undefined;
    userType?: number;
}

export class UserChangePasswordResponse implements IUserChangePasswordResponse {
    title?: string | undefined;
    description?: string | undefined;
    isSuccess?: boolean;

    constructor(data?: IUserChangePasswordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["Title"];
            this.description = _data["Description"];
            this.isSuccess = _data["IsSuccess"];
        }
    }

    static fromJS(data: any): UserChangePasswordResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserChangePasswordResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        data["Description"] = this.description;
        data["IsSuccess"] = this.isSuccess;
        return data;
    }
}

export interface IUserChangePasswordResponse {
    title?: string | undefined;
    description?: string | undefined;
    isSuccess?: boolean;
}

export class UserChangePasswordRequest implements IUserChangePasswordRequest {
    password?: string | undefined;
    userId?: number;
    newPassword?: string | undefined;
    requireOldPassword?: boolean;
    phone?: string | undefined;

    constructor(data?: IUserChangePasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["Password"];
            this.userId = _data["UserId"];
            this.newPassword = _data["NewPassword"];
            this.requireOldPassword = _data["RequireOldPassword"];
            this.phone = _data["Phone"];
        }
    }

    static fromJS(data: any): UserChangePasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserChangePasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Password"] = this.password;
        data["UserId"] = this.userId;
        data["NewPassword"] = this.newPassword;
        data["RequireOldPassword"] = this.requireOldPassword;
        data["Phone"] = this.phone;
        return data;
    }
}

export interface IUserChangePasswordRequest {
    password?: string | undefined;
    userId?: number;
    newPassword?: string | undefined;
    requireOldPassword?: boolean;
    phone?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}